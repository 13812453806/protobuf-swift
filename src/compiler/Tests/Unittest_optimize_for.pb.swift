// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation

private class UnittestOptimizeForRoot {
    private var TestOptimizedForSize_testExtension:ConcreteExtensionField<Int32,TestOptimizedForSize>
    private var TestOptimizedForSize_testExtension2:ConcreteExtensionField<TestRequiredOptimizedForSize,TestOptimizedForSize>
    var extensionRegistry:ExtensionRegistry

    init() {
        TestOptimizedForSize_testExtension = ConcreteExtensionField(type:ExtensionType.ExtensionTypeInt32, fieldNumber:1234, defaultValue:0, isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
        TestOptimizedForSize_testExtension2 = ConcreteExtensionField(type:ExtensionType.ExtensionTypeMessage, fieldNumber:1235, defaultValue:TestRequiredOptimizedForSize(), isRepeated:false, isPacked:false, isMessageSetWireFormat:false)
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(extensionRegistry)
        UnittestRoot.registerAllExtensions(registry)
      }
    func registerAllExtensions(registry:ExtensionRegistry) {
      registry.addExtension(TestOptimizedForSize_testExtension)
      registry.addExtension(TestOptimizedForSize_testExtension2)
    }
    }

func == (lhs: TestOptimizedForSize, rhs: TestOptimizedForSize) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasI == rhs.hasI) && (!lhs.hasI || lhs.i == rhs.i)
       fieldCheck = fieldCheck && (lhs.hasMsg == rhs.hasMsg) && (!lhs.hasMsg || lhs.msg == rhs.msg)
       fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
       return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}
class TestOptimizedForSize : ExtendableMessage {
  private(set) var hasI:Bool = false
  private(set) var i:Int32 = 0

  private(set) var hasMsg:Bool = false
  private(set) var msg:ForeignMessage = ForeignMessage()
  var testExtension:ExtensionField {
       get {
           return TestOptimizedForSize_testExtension
       }
  }
  var testExtension2:ExtensionField {
       get {
           return TestOptimizedForSize_testExtension2
       }
  }
  override init() {
       super.init()
  }
  override func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
      return false
    }
    return true
  }
  override func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasI {
      output.writeInt32(1, value:i)
    }
    if hasMsg {
      output.writeMessage(19, value:msg)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
      return size
    }

    size = 0
    if hasI {
      size += WireFormat.computeInt32Size(1, value:i)
    }
    if hasMsg {
      size += WireFormat.computeMessageSize(19, value:msg)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> TestOptimizedForSize {
    return TestOptimizedForSize.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOptimizedForSize {
    return TestOptimizedForSize.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> TestOptimizedForSize {
    return TestOptimizedForSize.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOptimizedForSize {
    return TestOptimizedForSize.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> TestOptimizedForSize {
    return TestOptimizedForSize.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOptimizedForSize {
    return TestOptimizedForSize.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> TestOptimizedForSizeBuilder {
    return TestOptimizedForSizeBuilder()
  }
  class func builderWithPrototype(prototype:TestOptimizedForSize) -> TestOptimizedForSizeBuilder {
    return TestOptimizedForSize.builder().mergeFrom(prototype)
  }
  func builder() -> TestOptimizedForSizeBuilder {
    return TestOptimizedForSize.builder()
  }
  func toBuilder() -> TestOptimizedForSizeBuilder {
    return TestOptimizedForSize.builderWithPrototype(self)
  }
  override func writeDescriptionTo(inout output:String, indent:String) {
    if hasI {
      output += "\(indent) i: \(i) \n"
    }
    if hasMsg {
      output += "\(indent) msg {\n"
      msg.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override var hashValue:Int {
   get {
        var hashCode:Int = 7
        if hasI {
           hashCode = (hashCode &* 31) &+ i.hashValue
        }
        if hasMsg {
          hashCode = (hashCode &* 31) &+ msg.hashValue
        }
        hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
        hashCode = (hashCode &* 31) &+  unknownFields.hashValue
        return hashCode
      }
    }
  }

  class TestOptimizedForSizeBuilder : ExtendableMessageBuilder {
  private var result:TestOptimizedForSize

  override init () {
     result = TestOptimizedForSize()
  }
  var hasI:Bool {
       get {
            return result.hasI
       }
  }
  var i:Int32 {
       get {
            return result.i
       }
       set (value) {
           result.hasI = true
           result.i = value
       }
  }
  func clearI() -> TestOptimizedForSizeBuilder{
       result.hasI = false
       result.i = 0
       return self
  }
  var hasMsg:Bool {
       get {
           return result.hasMsg
       }
  }
  var msg:ForeignMessage {
       get {
           return result.msg     }
       set (value) {
           result.hasMsg = true
           result.msg = value
       }
  }
  func setMsgBuilder(builderForValue:ForeignMessageBuilder) -> TestOptimizedForSizeBuilder {
    msg = builderForValue.build()
    return self
  }
  func mergeMsg(value:ForeignMessage) -> TestOptimizedForSizeBuilder {
    if (result.hasMsg && result.msg != ForeignMessage()) {
      result.msg = ForeignMessage.builderWithPrototype(result.msg).mergeFrom(value).buildPartial()
    } else {
      result.msg = value
    }
    result.hasMsg = true
    return self
  }
  func clearMsg() -> TestOptimizedForSizeBuilder {
    result.hasMsg = false
    result.msg = ForeignMessage()
    return self
  }
  override var internalGetResult:ExtendableMessage {
       get {
           return result
       }
  }
  override func clear() -> TestOptimizedForSizeBuilder {
    result = TestOptimizedForSize()
    return self
  }
  override func clone() -> TestOptimizedForSizeBuilder {
    return TestOptimizedForSize.builderWithPrototype(result)
  }
  func build() -> TestOptimizedForSize {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> TestOptimizedForSize {
    var returnMe:TestOptimizedForSize = result
    return returnMe
  }
  func mergeFrom(other:TestOptimizedForSize) -> TestOptimizedForSizeBuilder {
    if (other == TestOptimizedForSize()) {
      return self
    }
    if other.hasI {
         i = other.i
    }
    if (other.hasMsg) {
        mergeMsg(other.msg)
    }
    mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOptimizedForSizeBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOptimizedForSizeBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag:Int32 = input.readTag()
        if tag == 0 {
             self.unknownFields = unknownFieldsBuilder.build()
             return self}
        else if tag == 8 {
          i = input.readInt32()
        }
        else if tag == 154 {
          var subBuilder:ForeignMessageBuilder = ForeignMessage.builder()
          if hasMsg {
            subBuilder.mergeFrom(msg)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          msg = subBuilder.buildPartial()
        }
        else {
              if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                  unknownFields = unknownFieldsBuilder.build()
                  return self
              }
        }
        }
     }
  }

  func == (lhs: TestRequiredOptimizedForSize, rhs: TestRequiredOptimizedForSize) -> Bool {
        if (lhs === rhs) {
          return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasX == rhs.hasX) && (!lhs.hasX || lhs.x == rhs.x)
         return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  }
  class TestRequiredOptimizedForSize : GeneratedMessage {
    private(set) var hasX:Bool = false
    private(set) var x:Int32 = 0

    override init() {
         super.init()
    }
    override func isInitialized() -> Bool {
      if !hasX {
        return false
      }
      return true
    }
    override func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasX {
        output.writeInt32(1, value:x)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override func serializedSize() -> Int32 {
      var size:Int32 = memoizedSerializedSize
      if size != -1 {
        return size
      }

      size = 0
      if hasX {
        size += WireFormat.computeInt32Size(1, value:x)
      }
      size += unknownFields.serializedSize()
      memoizedSerializedSize = size
      return size
    }
    class func parseFromData(data:[Byte]) -> TestRequiredOptimizedForSize {
      return TestRequiredOptimizedForSize.builder().mergeFromData(data).build()
    }
    class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestRequiredOptimizedForSize {
      return TestRequiredOptimizedForSize.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    class func parseFromInputStream(input:NSInputStream) -> TestRequiredOptimizedForSize {
      return TestRequiredOptimizedForSize.builder().mergeFromInputStream(input).build()
    }
    class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestRequiredOptimizedForSize {
      return TestRequiredOptimizedForSize.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    class func parseFromCodedInputStream(input:CodedInputStream) -> TestRequiredOptimizedForSize {
      return TestRequiredOptimizedForSize.builder().mergeFromCodedInputStream(input).build()
    }
    class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredOptimizedForSize {
      return TestRequiredOptimizedForSize.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    class func builder() -> TestRequiredOptimizedForSizeBuilder {
      return TestRequiredOptimizedForSizeBuilder()
    }
    class func builderWithPrototype(prototype:TestRequiredOptimizedForSize) -> TestRequiredOptimizedForSizeBuilder {
      return TestRequiredOptimizedForSize.builder().mergeFrom(prototype)
    }
    func builder() -> TestRequiredOptimizedForSizeBuilder {
      return TestRequiredOptimizedForSize.builder()
    }
    func toBuilder() -> TestRequiredOptimizedForSizeBuilder {
      return TestRequiredOptimizedForSize.builderWithPrototype(self)
    }
    override func writeDescriptionTo(inout output:String, indent:String) {
      if hasX {
        output += "\(indent) x: \(x) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override var hashValue:Int {
     get {
          var hashCode:Int = 7
          if hasX {
             hashCode = (hashCode &* 31) &+ x.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
        }
      }
    }

    class TestRequiredOptimizedForSizeBuilder : GeneratedMessageBuilder {
    private var result:TestRequiredOptimizedForSize

    override init () {
       result = TestRequiredOptimizedForSize()
    }
    var hasX:Bool {
         get {
              return result.hasX
         }
    }
    var x:Int32 {
         get {
              return result.x
         }
         set (value) {
             result.hasX = true
             result.x = value
         }
    }
    func clearX() -> TestRequiredOptimizedForSizeBuilder{
         result.hasX = false
         result.x = 0
         return self
    }
    override var internalGetResult:GeneratedMessage {
         get {
            return result
         }
    }
    override func clear() -> TestRequiredOptimizedForSizeBuilder {
      result = TestRequiredOptimizedForSize()
      return self
    }
    override func clone() -> TestRequiredOptimizedForSizeBuilder {
      return TestRequiredOptimizedForSize.builderWithPrototype(result)
    }
    func build() -> TestRequiredOptimizedForSize {
         checkInitialized()
         return buildPartial()
    }
    func buildPartial() -> TestRequiredOptimizedForSize {
      var returnMe:TestRequiredOptimizedForSize = result
      return returnMe
    }
    func mergeFrom(other:TestRequiredOptimizedForSize) -> TestRequiredOptimizedForSizeBuilder {
      if (other == TestRequiredOptimizedForSize()) {
        return self
      }
      if other.hasX {
           x = other.x
      }
        mergeUnknownFields(other.unknownFields)
      return self
    }
    override func mergeFromCodedInputStream(input:CodedInputStream) ->TestRequiredOptimizedForSizeBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestRequiredOptimizedForSizeBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag:Int32 = input.readTag()
          if tag == 0 {
               self.unknownFields = unknownFieldsBuilder.build()
               return self}
          else if tag == 8 {
            x = input.readInt32()
          }
          else {
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                    unknownFields = unknownFieldsBuilder.build()
                    return self
                }
          }
          }
       }
    }

    func == (lhs: TestOptionalOptimizedForSize, rhs: TestOptionalOptimizedForSize) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasO == rhs.hasO) && (!lhs.hasO || lhs.o == rhs.o)
           return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
    }
    class TestOptionalOptimizedForSize : GeneratedMessage {
      private(set) var hasO:Bool = false
      private(set) var o:TestRequiredOptimizedForSize = TestRequiredOptimizedForSize()
      override init() {
           super.init()
      }
      override func isInitialized() -> Bool {
        if hasO {
          if !o.isInitialized() {
            return false
          }
        }
        return true
      }
      override func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasO {
          output.writeMessage(1, value:o)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
          return size
        }

        size = 0
        if hasO {
          size += WireFormat.computeMessageSize(1, value:o)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      class func parseFromData(data:[Byte]) -> TestOptionalOptimizedForSize {
        return TestOptionalOptimizedForSize.builder().mergeFromData(data).build()
      }
      class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> TestOptionalOptimizedForSize {
        return TestOptionalOptimizedForSize.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromInputStream(input:NSInputStream) -> TestOptionalOptimizedForSize {
        return TestOptionalOptimizedForSize.builder().mergeFromInputStream(input).build()
      }
      class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->TestOptionalOptimizedForSize {
        return TestOptionalOptimizedForSize.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream) -> TestOptionalOptimizedForSize {
        return TestOptionalOptimizedForSize.builder().mergeFromCodedInputStream(input).build()
      }
      class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOptionalOptimizedForSize {
        return TestOptionalOptimizedForSize.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      class func builder() -> TestOptionalOptimizedForSizeBuilder {
        return TestOptionalOptimizedForSizeBuilder()
      }
      class func builderWithPrototype(prototype:TestOptionalOptimizedForSize) -> TestOptionalOptimizedForSizeBuilder {
        return TestOptionalOptimizedForSize.builder().mergeFrom(prototype)
      }
      func builder() -> TestOptionalOptimizedForSizeBuilder {
        return TestOptionalOptimizedForSize.builder()
      }
      func toBuilder() -> TestOptionalOptimizedForSizeBuilder {
        return TestOptionalOptimizedForSize.builderWithPrototype(self)
      }
      override func writeDescriptionTo(inout output:String, indent:String) {
        if hasO {
          output += "\(indent) o {\n"
          o.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent) }\n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override var hashValue:Int {
       get {
            var hashCode:Int = 7
            if hasO {
              hashCode = (hashCode &* 31) &+ o.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
          }
        }
      }

      class TestOptionalOptimizedForSizeBuilder : GeneratedMessageBuilder {
      private var result:TestOptionalOptimizedForSize

      override init () {
         result = TestOptionalOptimizedForSize()
      }
      var hasO:Bool {
           get {
               return result.hasO
           }
      }
      var o:TestRequiredOptimizedForSize {
           get {
               return result.o     }
           set (value) {
               result.hasO = true
               result.o = value
           }
      }
      func setOBuilder(builderForValue:TestRequiredOptimizedForSizeBuilder) -> TestOptionalOptimizedForSizeBuilder {
        o = builderForValue.build()
        return self
      }
      func mergeO(value:TestRequiredOptimizedForSize) -> TestOptionalOptimizedForSizeBuilder {
        if (result.hasO && result.o != TestRequiredOptimizedForSize()) {
          result.o = TestRequiredOptimizedForSize.builderWithPrototype(result.o).mergeFrom(value).buildPartial()
        } else {
          result.o = value
        }
        result.hasO = true
        return self
      }
      func clearO() -> TestOptionalOptimizedForSizeBuilder {
        result.hasO = false
        result.o = TestRequiredOptimizedForSize()
        return self
      }
      override var internalGetResult:GeneratedMessage {
           get {
              return result
           }
      }
      override func clear() -> TestOptionalOptimizedForSizeBuilder {
        result = TestOptionalOptimizedForSize()
        return self
      }
      override func clone() -> TestOptionalOptimizedForSizeBuilder {
        return TestOptionalOptimizedForSize.builderWithPrototype(result)
      }
      func build() -> TestOptionalOptimizedForSize {
           checkInitialized()
           return buildPartial()
      }
      func buildPartial() -> TestOptionalOptimizedForSize {
        var returnMe:TestOptionalOptimizedForSize = result
        return returnMe
      }
      func mergeFrom(other:TestOptionalOptimizedForSize) -> TestOptionalOptimizedForSizeBuilder {
        if (other == TestOptionalOptimizedForSize()) {
          return self
        }
        if (other.hasO) {
            mergeO(other.o)
        }
          mergeUnknownFields(other.unknownFields)
        return self
      }
      override func mergeFromCodedInputStream(input:CodedInputStream) ->TestOptionalOptimizedForSizeBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> TestOptionalOptimizedForSizeBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag:Int32 = input.readTag()
            if tag == 0 {
                 self.unknownFields = unknownFieldsBuilder.build()
                 return self}
            else if tag == 10 {
              var subBuilder:TestRequiredOptimizedForSizeBuilder = TestRequiredOptimizedForSize.builder()
              if hasO {
                subBuilder.mergeFrom(o)
              }
              input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              o = subBuilder.buildPartial()
            }
            else {
                  if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                      unknownFields = unknownFieldsBuilder.build()
                      return self
                  }
            }
            }
         }
      }


      // @@protoc_insertion_point(global_scope)
