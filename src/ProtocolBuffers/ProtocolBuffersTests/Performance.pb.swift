// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers


internal func == (lhs: IceCreamCone, rhs: IceCreamCone) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMapper == rhs.hasMapper) && (!lhs.hasMapper || lhs.mapper == rhs.mapper)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal func == (lhs: IceCreamCone.MapperEntry, rhs: IceCreamCone.MapperEntry) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal func == (lhs: ProtoPoint, rhs: ProtoPoint) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

internal struct Performance {
  internal static var sharedInstance : Performance {
   struct Static {
       static let instance : Performance = Performance()
   }
   return Static.instance
  }
  internal var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  internal func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final internal class IceCreamCone : GeneratedMessage, GeneratedMessageProtocol, Hashable {


  //Nested type declaration start

    final internal class MapperEntry : GeneratedMessage, GeneratedMessageProtocol, Hashable {
      private(set) var hasKey:Bool = false
      private(set) var key:Int32 = Int32(0)

      private(set) var hasValue:Bool = false
      private(set) var value:ProtoPoint!
      required internal init() {
           super.init()
      }
      override internal func isInitialized() -> Bool {
       return true
      }
      override internal func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasKey {
          output.writeInt32(1, value:key)
        }
        if hasValue {
          output.writeMessage(2, value:value)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override internal func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasKey {
          serialize_size += key.computeInt32Size(1)
        }
        if hasValue {
            if let varSizevalue = value?.computeMessageSize(2) {
                serialize_size += varSizevalue
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      internal class func parseFromData(data:NSData) -> IceCreamCone.MapperEntry {
        return IceCreamCone.MapperEntry.builder().mergeFromData(data, extensionRegistry:Performance.sharedInstance.extensionRegistry).build()
      }
      internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> IceCreamCone.MapperEntry {
        return IceCreamCone.MapperEntry.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      internal class func parseFromInputStream(input:NSInputStream) -> IceCreamCone.MapperEntry {
        return IceCreamCone.MapperEntry.builder().mergeFromInputStream(input).build()
      }
      internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->IceCreamCone.MapperEntry {
        return IceCreamCone.MapperEntry.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      internal class func parseFromCodedInputStream(input:CodedInputStream) -> IceCreamCone.MapperEntry {
        return IceCreamCone.MapperEntry.builder().mergeFromCodedInputStream(input).build()
      }
      internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> IceCreamCone.MapperEntry {
        return IceCreamCone.MapperEntry.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      internal class func builder() -> IceCreamCone.MapperEntryBuilder {
        return IceCreamCone.MapperEntry.classBuilder() as! IceCreamCone.MapperEntryBuilder
      }
      internal func builder() -> IceCreamCone.MapperEntryBuilder {
        return classBuilder() as! IceCreamCone.MapperEntryBuilder
      }
      internal override class func classBuilder() -> MessageBuilder {
        return IceCreamCone.MapperEntryBuilder()
      }
      internal override func classBuilder() -> MessageBuilder {
        return IceCreamCone.MapperEntry.builder()
      }
      internal func toBuilder() -> IceCreamCone.MapperEntryBuilder {
        return IceCreamCone.MapperEntry.builderWithPrototype(self)
      }
      internal class func builderWithPrototype(prototype:IceCreamCone.MapperEntry) -> IceCreamCone.MapperEntryBuilder {
        return IceCreamCone.MapperEntry.builder().mergeFrom(prototype)
      }
      override internal func writeDescriptionTo(inout output:String, indent:String) {
        if hasKey {
          output += "\(indent) key: \(key) \n"
        }
        if hasValue {
          output += "\(indent) value {\n"
          value?.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent) }\n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override internal var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasKey {
                 hashCode = (hashCode &* 31) &+ key.hashValue
              }
              if hasValue {
                  if let hashValuevalue = value?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuevalue
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override internal class func className() -> String {
          return "IceCreamCone.MapperEntry"
      }
      override internal func className() -> String {
          return "IceCreamCone.MapperEntry"
      }
      override internal func classMetaType() -> GeneratedMessage.Type {
          return IceCreamCone.MapperEntry.self
      }
      //Meta information declaration end

    }

    final internal class MapperEntryBuilder : GeneratedMessageBuilder {
      private var builderResult:IceCreamCone.MapperEntry

      required override internal init () {
         builderResult = IceCreamCone.MapperEntry()
         super.init()
      }
      var hasKey:Bool {
           get {
                return builderResult.hasKey
           }
      }
      var key:Int32 {
           get {
                return builderResult.key
           }
           set (value) {
               builderResult.hasKey = true
               builderResult.key = value
           }
      }
      func setKey(value:Int32)-> IceCreamCone.MapperEntryBuilder {
        self.key = value
        return self
      }
      internal func clearKey() -> IceCreamCone.MapperEntryBuilder{
           builderResult.hasKey = false
           builderResult.key = Int32(0)
           return self
      }
      var hasValue:Bool {
           get {
               return builderResult.hasValue
           }
      }
      var value:ProtoPoint! {
           get {
               return builderResult.value
           }
           set (value) {
               builderResult.hasValue = true
               builderResult.value = value
           }
      }
      func setValue(value:ProtoPoint!)-> IceCreamCone.MapperEntryBuilder {
        self.value = value
        return self
      }
      internal func mergeValue(value:ProtoPoint) -> IceCreamCone.MapperEntryBuilder {
        if (builderResult.hasValue) {
          builderResult.value = ProtoPoint.builderWithPrototype(builderResult.value).mergeFrom(value).buildPartial()
        } else {
          builderResult.value = value
        }
        builderResult.hasValue = true
        return self
      }
      internal func clearValue() -> IceCreamCone.MapperEntryBuilder {
        builderResult.hasValue = false
        builderResult.value = nil
        return self
      }
      override internal var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      internal override func clear() -> IceCreamCone.MapperEntryBuilder {
        builderResult = IceCreamCone.MapperEntry()
        return self
      }
      internal override func clone() -> IceCreamCone.MapperEntryBuilder {
        return IceCreamCone.MapperEntry.builderWithPrototype(builderResult)
      }
      internal override func build() -> IceCreamCone.MapperEntry {
           checkInitialized()
           return buildPartial()
      }
      internal func buildPartial() -> IceCreamCone.MapperEntry {
        var returnMe:IceCreamCone.MapperEntry = builderResult
        return returnMe
      }
      internal func mergeFrom(other:IceCreamCone.MapperEntry) -> IceCreamCone.MapperEntryBuilder {
        if (other == IceCreamCone.MapperEntry()) {
         return self
        }
        if other.hasKey {
             key = other.key
        }
        if (other.hasValue) {
            mergeValue(other.value)
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream) ->IceCreamCone.MapperEntryBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> IceCreamCone.MapperEntryBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 8 :
            key = input.readInt32()

          case 18 :
            var subBuilder:ProtoPointBuilder = ProtoPoint.builder()
            if hasValue {
              subBuilder.mergeFrom(value)
            }
            input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            value = subBuilder.buildPartial()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  //Nested type declaration end

  private(set) var hasMapper:Bool = false
  private(set) var mapper:[Int32:ProtoPoint] = [Int32:ProtoPoint]()

  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasMapper {
        for (keyMapper, valueMapper) in mapper {
            var valueOfMapper = IceCreamCone.MapperEntry.builder().setKey(keyMapper).setValue(valueMapper).build()
            output.writeMessage(3, value:valueOfMapper)
        }
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMapper {
        for (keyMapper, valueMapper) in mapper {
            var valueOfMapper = IceCreamCone.MapperEntry.builder().setKey(keyMapper).setValue(valueMapper).build()
            output.computeMessage(3, value:valueOfMapper)
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  internal class func parseFromData(data:NSData) -> IceCreamCone {
    return IceCreamCone.builder().mergeFromData(data, extensionRegistry:Performance.sharedInstance.extensionRegistry).build()
  }
  internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> IceCreamCone {
    return IceCreamCone.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> IceCreamCone {
    return IceCreamCone.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->IceCreamCone {
    return IceCreamCone.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> IceCreamCone {
    return IceCreamCone.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> IceCreamCone {
    return IceCreamCone.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> IceCreamConeBuilder {
    return IceCreamCone.classBuilder() as! IceCreamConeBuilder
  }
  internal func builder() -> IceCreamConeBuilder {
    return classBuilder() as! IceCreamConeBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return IceCreamConeBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return IceCreamCone.builder()
  }
  internal func toBuilder() -> IceCreamConeBuilder {
    return IceCreamCone.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:IceCreamCone) -> IceCreamConeBuilder {
    return IceCreamCone.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    if hasMapper {
      output += "\(indent) mapper: \(mapper) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMapper {
             hashCode = (hashCode &* 31) &+ mapper.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "IceCreamCone"
  }
  override internal func className() -> String {
      return "IceCreamCone"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return IceCreamCone.self
  }
  //Meta information declaration end

}

final internal class IceCreamConeBuilder : GeneratedMessageBuilder {
  private var builderResult:IceCreamCone

  required override internal init () {
     builderResult = IceCreamCone()
     super.init()
  }
  var hasMapper:Bool {
       get {
            return builderResult.hasMapper
       }
  }
  var mapper:[Int32:ProtoPoint] {
       get {
            return builderResult.mapper
       }
       set (value) {
           builderResult.hasMapper = true
           builderResult.mapper = value
       }
  }
  func setMapper(value:[Int32:ProtoPoint])-> IceCreamConeBuilder {
    self.mapper = value
    return self
  }
  internal func clearMapper() -> IceCreamConeBuilder{
       builderResult.hasMapper = false
       builderResult.mapper = [Int32:ProtoPoint]()
       return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> IceCreamConeBuilder {
    builderResult = IceCreamCone()
    return self
  }
  internal override func clone() -> IceCreamConeBuilder {
    return IceCreamCone.builderWithPrototype(builderResult)
  }
  internal override func build() -> IceCreamCone {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> IceCreamCone {
    var returnMe:IceCreamCone = builderResult
    return returnMe
  }
  internal func mergeFrom(other:IceCreamCone) -> IceCreamConeBuilder {
    if (other == IceCreamCone()) {
     return self
    }
    if other.hasMapper {
         mapper = other.mapper
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->IceCreamConeBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> IceCreamConeBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 26 :

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final internal class ProtoPoint : GeneratedMessage, GeneratedMessageProtocol, Hashable {
  private(set) var hasLatitude:Bool = false
  private(set) var latitude:Float = Float(0)

  private(set) var hasLongitude:Bool = false
  private(set) var longitude:Float = Float(0)

  required internal init() {
       super.init()
  }
  override internal func isInitialized() -> Bool {
   return true
  }
  override internal func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasLatitude {
      output.writeFloat(1, value:latitude)
    }
    if hasLongitude {
      output.writeFloat(2, value:longitude)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override internal func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasLatitude {
      serialize_size += latitude.computeFloatSize(1)
    }
    if hasLongitude {
      serialize_size += longitude.computeFloatSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  internal class func parseFromData(data:NSData) -> ProtoPoint {
    return ProtoPoint.builder().mergeFromData(data, extensionRegistry:Performance.sharedInstance.extensionRegistry).build()
  }
  internal class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> ProtoPoint {
    return ProtoPoint.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromInputStream(input:NSInputStream) -> ProtoPoint {
    return ProtoPoint.builder().mergeFromInputStream(input).build()
  }
  internal class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ProtoPoint {
    return ProtoPoint.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream) -> ProtoPoint {
    return ProtoPoint.builder().mergeFromCodedInputStream(input).build()
  }
  internal class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ProtoPoint {
    return ProtoPoint.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  internal class func builder() -> ProtoPointBuilder {
    return ProtoPoint.classBuilder() as! ProtoPointBuilder
  }
  internal func builder() -> ProtoPointBuilder {
    return classBuilder() as! ProtoPointBuilder
  }
  internal override class func classBuilder() -> MessageBuilder {
    return ProtoPointBuilder()
  }
  internal override func classBuilder() -> MessageBuilder {
    return ProtoPoint.builder()
  }
  internal func toBuilder() -> ProtoPointBuilder {
    return ProtoPoint.builderWithPrototype(self)
  }
  internal class func builderWithPrototype(prototype:ProtoPoint) -> ProtoPointBuilder {
    return ProtoPoint.builder().mergeFrom(prototype)
  }
  override internal func writeDescriptionTo(inout output:String, indent:String) {
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override internal var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override internal class func className() -> String {
      return "ProtoPoint"
  }
  override internal func className() -> String {
      return "ProtoPoint"
  }
  override internal func classMetaType() -> GeneratedMessage.Type {
      return ProtoPoint.self
  }
  //Meta information declaration end

}

final internal class ProtoPointBuilder : GeneratedMessageBuilder {
  private var builderResult:ProtoPoint

  required override internal init () {
     builderResult = ProtoPoint()
     super.init()
  }
  var hasLatitude:Bool {
       get {
            return builderResult.hasLatitude
       }
  }
  var latitude:Float {
       get {
            return builderResult.latitude
       }
       set (value) {
           builderResult.hasLatitude = true
           builderResult.latitude = value
       }
  }
  func setLatitude(value:Float)-> ProtoPointBuilder {
    self.latitude = value
    return self
  }
  internal func clearLatitude() -> ProtoPointBuilder{
       builderResult.hasLatitude = false
       builderResult.latitude = Float(0)
       return self
  }
  var hasLongitude:Bool {
       get {
            return builderResult.hasLongitude
       }
  }
  var longitude:Float {
       get {
            return builderResult.longitude
       }
       set (value) {
           builderResult.hasLongitude = true
           builderResult.longitude = value
       }
  }
  func setLongitude(value:Float)-> ProtoPointBuilder {
    self.longitude = value
    return self
  }
  internal func clearLongitude() -> ProtoPointBuilder{
       builderResult.hasLongitude = false
       builderResult.longitude = Float(0)
       return self
  }
  override internal var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  internal override func clear() -> ProtoPointBuilder {
    builderResult = ProtoPoint()
    return self
  }
  internal override func clone() -> ProtoPointBuilder {
    return ProtoPoint.builderWithPrototype(builderResult)
  }
  internal override func build() -> ProtoPoint {
       checkInitialized()
       return buildPartial()
  }
  internal func buildPartial() -> ProtoPoint {
    var returnMe:ProtoPoint = builderResult
    return returnMe
  }
  internal func mergeFrom(other:ProtoPoint) -> ProtoPointBuilder {
    if (other == ProtoPoint()) {
     return self
    }
    if other.hasLatitude {
         latitude = other.latitude
    }
    if other.hasLongitude {
         longitude = other.longitude
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream) ->ProtoPointBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  internal override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ProtoPointBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 13 :
        latitude = input.readFloat()

      case 21 :
        longitude = input.readFloat()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}


// @@protoc_insertion_point(global_scope)
