// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation

public struct Google { public struct Protobuf { }}

public func == (lhs: FileDescriptorSet, rhs: FileDescriptorSet) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.file == rhs.file)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: FileDescriptorProto, rhs: FileDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasPackage == rhs.hasPackage) && (!lhs.hasPackage || lhs.package == rhs.package)
  fieldCheck = fieldCheck && (lhs.dependency == rhs.dependency)
  fieldCheck = fieldCheck && (lhs.messageType == rhs.messageType)
  fieldCheck = fieldCheck && (lhs.enumType == rhs.enumType)
  fieldCheck = fieldCheck && (lhs.service == rhs.service)
  fieldCheck = fieldCheck && (lhs.extension_ == rhs.extension_)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = fieldCheck && (lhs.hasSourceCodeInfo == rhs.hasSourceCodeInfo) && (!lhs.hasSourceCodeInfo || lhs.sourceCodeInfo == rhs.sourceCodeInfo)
  fieldCheck = fieldCheck && (lhs.publicDependency == rhs.publicDependency)
  fieldCheck = fieldCheck && (lhs.weakDependency == rhs.weakDependency)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Google.Protobuf.DescriptorProto, rhs: Google.Protobuf.DescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
  fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: DescriptorProto, rhs: DescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.field == rhs.field)
  fieldCheck = fieldCheck && (lhs.nestedType == rhs.nestedType)
  fieldCheck = fieldCheck && (lhs.enumType == rhs.enumType)
  fieldCheck = fieldCheck && (lhs.extensionRange == rhs.extensionRange)
  fieldCheck = fieldCheck && (lhs.extension_ == rhs.extension_)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = fieldCheck && (lhs.oneofDecl == rhs.oneofDecl)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: FieldDescriptorProto, rhs: FieldDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasExtendee == rhs.hasExtendee) && (!lhs.hasExtendee || lhs.extendee == rhs.extendee)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasTypeName == rhs.hasTypeName) && (!lhs.hasTypeName || lhs.typeName == rhs.typeName)
  fieldCheck = fieldCheck && (lhs.hasDefaultValue == rhs.hasDefaultValue) && (!lhs.hasDefaultValue || lhs.defaultValue == rhs.defaultValue)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  fieldCheck = fieldCheck && (lhs.hasOneofIndex == rhs.hasOneofIndex) && (!lhs.hasOneofIndex || lhs.oneofIndex == rhs.oneofIndex)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: OneofDescriptorProto, rhs: OneofDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: EnumDescriptorProto, rhs: EnumDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.value == rhs.value)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: EnumValueDescriptorProto, rhs: EnumValueDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ServiceDescriptorProto, rhs: ServiceDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.method == rhs.method)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: MethodDescriptorProto, rhs: MethodDescriptorProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasInputType == rhs.hasInputType) && (!lhs.hasInputType || lhs.inputType == rhs.inputType)
  fieldCheck = fieldCheck && (lhs.hasOutputType == rhs.hasOutputType) && (!lhs.hasOutputType || lhs.outputType == rhs.outputType)
  fieldCheck = fieldCheck && (lhs.hasOptions == rhs.hasOptions) && (!lhs.hasOptions || lhs.options == rhs.options)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: FileOptions, rhs: FileOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasJavaPackage == rhs.hasJavaPackage) && (!lhs.hasJavaPackage || lhs.javaPackage == rhs.javaPackage)
  fieldCheck = fieldCheck && (lhs.hasJavaOuterClassname == rhs.hasJavaOuterClassname) && (!lhs.hasJavaOuterClassname || lhs.javaOuterClassname == rhs.javaOuterClassname)
  fieldCheck = fieldCheck && (lhs.hasOptimizeFor == rhs.hasOptimizeFor) && (!lhs.hasOptimizeFor || lhs.optimizeFor == rhs.optimizeFor)
  fieldCheck = fieldCheck && (lhs.hasJavaMultipleFiles == rhs.hasJavaMultipleFiles) && (!lhs.hasJavaMultipleFiles || lhs.javaMultipleFiles == rhs.javaMultipleFiles)
  fieldCheck = fieldCheck && (lhs.hasGoPackage == rhs.hasGoPackage) && (!lhs.hasGoPackage || lhs.goPackage == rhs.goPackage)
  fieldCheck = fieldCheck && (lhs.hasCcGenericServices == rhs.hasCcGenericServices) && (!lhs.hasCcGenericServices || lhs.ccGenericServices == rhs.ccGenericServices)
  fieldCheck = fieldCheck && (lhs.hasJavaGenericServices == rhs.hasJavaGenericServices) && (!lhs.hasJavaGenericServices || lhs.javaGenericServices == rhs.javaGenericServices)
  fieldCheck = fieldCheck && (lhs.hasPyGenericServices == rhs.hasPyGenericServices) && (!lhs.hasPyGenericServices || lhs.pyGenericServices == rhs.pyGenericServices)
  fieldCheck = fieldCheck && (lhs.hasJavaGenerateEqualsAndHash == rhs.hasJavaGenerateEqualsAndHash) && (!lhs.hasJavaGenerateEqualsAndHash || lhs.javaGenerateEqualsAndHash == rhs.javaGenerateEqualsAndHash)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.hasJavaStringCheckUtf8 == rhs.hasJavaStringCheckUtf8) && (!lhs.hasJavaStringCheckUtf8 || lhs.javaStringCheckUtf8 == rhs.javaStringCheckUtf8)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: MessageOptions, rhs: MessageOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMessageSetWireFormat == rhs.hasMessageSetWireFormat) && (!lhs.hasMessageSetWireFormat || lhs.messageSetWireFormat == rhs.messageSetWireFormat)
  fieldCheck = fieldCheck && (lhs.hasNoStandardDescriptorAccessor == rhs.hasNoStandardDescriptorAccessor) && (!lhs.hasNoStandardDescriptorAccessor || lhs.noStandardDescriptorAccessor == rhs.noStandardDescriptorAccessor)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: FieldOptions, rhs: FieldOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCtype == rhs.hasCtype) && (!lhs.hasCtype || lhs.ctype == rhs.ctype)
  fieldCheck = fieldCheck && (lhs.hasPacked == rhs.hasPacked) && (!lhs.hasPacked || lhs.packed == rhs.packed)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.hasLazy == rhs.hasLazy) && (!lhs.hasLazy || lhs.lazy == rhs.lazy)
  fieldCheck = fieldCheck && (lhs.hasExperimentalMapKey == rhs.hasExperimentalMapKey) && (!lhs.hasExperimentalMapKey || lhs.experimentalMapKey == rhs.experimentalMapKey)
  fieldCheck = fieldCheck && (lhs.hasWeak == rhs.hasWeak) && (!lhs.hasWeak || lhs.weak == rhs.weak)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: EnumOptions, rhs: EnumOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAllowAlias == rhs.hasAllowAlias) && (!lhs.hasAllowAlias || lhs.allowAlias == rhs.allowAlias)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: EnumValueOptions, rhs: EnumValueOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ServiceOptions, rhs: ServiceOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: MethodOptions, rhs: MethodOptions) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasDeprecated == rhs.hasDeprecated) && (!lhs.hasDeprecated || lhs.deprecated == rhs.deprecated)
  fieldCheck = fieldCheck && (lhs.uninterpretedOption == rhs.uninterpretedOption)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Google.Protobuf.UninterpretedOption, rhs: Google.Protobuf.UninterpretedOption) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNamePart == rhs.hasNamePart) && (!lhs.hasNamePart || lhs.namePart == rhs.namePart)
  fieldCheck = fieldCheck && (lhs.hasIsExtension == rhs.hasIsExtension) && (!lhs.hasIsExtension || lhs.isExtension == rhs.isExtension)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: UninterpretedOption, rhs: UninterpretedOption) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasIdentifierValue == rhs.hasIdentifierValue) && (!lhs.hasIdentifierValue || lhs.identifierValue == rhs.identifierValue)
  fieldCheck = fieldCheck && (lhs.hasPositiveIntValue == rhs.hasPositiveIntValue) && (!lhs.hasPositiveIntValue || lhs.positiveIntValue == rhs.positiveIntValue)
  fieldCheck = fieldCheck && (lhs.hasNegativeIntValue == rhs.hasNegativeIntValue) && (!lhs.hasNegativeIntValue || lhs.negativeIntValue == rhs.negativeIntValue)
  fieldCheck = fieldCheck && (lhs.hasDoubleValue == rhs.hasDoubleValue) && (!lhs.hasDoubleValue || lhs.doubleValue == rhs.doubleValue)
  fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
  fieldCheck = fieldCheck && (lhs.hasAggregateValue == rhs.hasAggregateValue) && (!lhs.hasAggregateValue || lhs.aggregateValue == rhs.aggregateValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Google.Protobuf.SourceCodeInfo, rhs: Google.Protobuf.SourceCodeInfo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.path == rhs.path)
  fieldCheck = fieldCheck && (lhs.span == rhs.span)
  fieldCheck = fieldCheck && (lhs.hasLeadingComments == rhs.hasLeadingComments) && (!lhs.hasLeadingComments || lhs.leadingComments == rhs.leadingComments)
  fieldCheck = fieldCheck && (lhs.hasTrailingComments == rhs.hasTrailingComments) && (!lhs.hasTrailingComments || lhs.trailingComments == rhs.trailingComments)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: SourceCodeInfo, rhs: SourceCodeInfo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.location == rhs.location)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public extension Google.Protobuf {
  public struct DescriptorRoot {
    public static var sharedInstance : DescriptorRoot {
     struct Static {
         static let instance : DescriptorRoot = DescriptorRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  final public class FileDescriptorSet : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var file:Array<FileDescriptorProto>  = Array<FileDescriptorProto>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitfile:Bool = true
      for oneElementfile in file {
          if (!oneElementfile.isInitialized()) {
              isInitfile = false
              break 
          }
      }
      if !isInitfile {
       return isInitfile
       }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      for oneElementfile in file {
          output.writeMessage(1, value:oneElementfile)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementfile in file {
          serialize_size += oneElementfile.computeMessageSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> FileDescriptorSet {
      return FileDescriptorSet.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> FileDescriptorSet {
      return FileDescriptorSet.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> FileDescriptorSet {
      return FileDescriptorSet.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FileDescriptorSet {
      return FileDescriptorSet.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> FileDescriptorSet {
      return FileDescriptorSet.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FileDescriptorSet {
      return FileDescriptorSet.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> FileDescriptorSetBuilder {
      return FileDescriptorSet.classBuilder() as! FileDescriptorSetBuilder
    }
    public func builder() -> FileDescriptorSetBuilder {
      return classBuilder() as! FileDescriptorSetBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return FileDescriptorSetBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return FileDescriptorSet.builder()
    }
    public func toBuilder() -> FileDescriptorSetBuilder {
      return FileDescriptorSet.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:FileDescriptorSet) -> FileDescriptorSetBuilder {
      return FileDescriptorSet.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      var fileElementIndex:Int = 0
      for oneElementfile in file {
          output += "\(indent) file[\(fileElementIndex)] {\n"
          oneElementfile.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          fileElementIndex++
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementfile in file {
                hashCode = (hashCode &* 31) &+ oneElementfile.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "FileDescriptorSet"
    }
    override public func className() -> String {
        return "FileDescriptorSet"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return FileDescriptorSet.self
    }
    //Meta information declaration end

  }

  final public class FileDescriptorSetBuilder : GeneratedMessageBuilder {
    private var builderResult:FileDescriptorSet

    required override public init () {
       builderResult = FileDescriptorSet()
       super.init()
    }
    public var file:Array<FileDescriptorProto> {
         get {
             return builderResult.file
         }
         set (value) {
             builderResult.file = value
         }
    }
    public func setFile(value:Array<FileDescriptorProto>)-> FileDescriptorProtoBuilder {
      self.file = value
      return self
    }
    public func clearFile() -> FileDescriptorProtoBuilder {
      builderResult.file.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> FileDescriptorSetBuilder {
      builderResult = FileDescriptorSet()
      return self
    }
    public override func clone() -> FileDescriptorSetBuilder {
      return FileDescriptorSet.builderWithPrototype(builderResult)
    }
    public override func build() -> FileDescriptorSet {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> FileDescriptorSet {
      var returnMe:FileDescriptorSet = builderResult
      return returnMe
    }
    public func mergeFrom(other:FileDescriptorSet) -> FileDescriptorSetBuilder {
      if (other == FileDescriptorSet()) {
       return self
      }
      if !other.file.isEmpty  {
         builderResult.file += other.file
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->FileDescriptorSetBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FileDescriptorSetBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          var subBuilder = FileDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          file += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class FileDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasPackage:Bool = false
    public private(set) var package:String = ""

    public private(set) var hasOptions:Bool = false
    public private(set) var options:FileOptions!
    public private(set) var hasSourceCodeInfo:Bool = false
    public private(set) var sourceCodeInfo:SourceCodeInfo!
    public private(set) var dependency:Array<String> = Array<String>()
    public private(set) var publicDependency:Array<Int32> = Array<Int32>()
    public private(set) var weakDependency:Array<Int32> = Array<Int32>()
    public private(set) var messageType:Array<DescriptorProto>  = Array<DescriptorProto>()
    public private(set) var enumType:Array<EnumDescriptorProto>  = Array<EnumDescriptorProto>()
    public private(set) var service:Array<ServiceDescriptorProto>  = Array<ServiceDescriptorProto>()
    public private(set) var extension_:Array<FieldDescriptorProto>  = Array<FieldDescriptorProto>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitmessageType:Bool = true
      for oneElementmessageType in messageType {
          if (!oneElementmessageType.isInitialized()) {
              isInitmessageType = false
              break 
          }
      }
      if !isInitmessageType {
       return isInitmessageType
       }
      var isInitenumType:Bool = true
      for oneElementenumType in enumType {
          if (!oneElementenumType.isInitialized()) {
              isInitenumType = false
              break 
          }
      }
      if !isInitenumType {
       return isInitenumType
       }
      var isInitservice:Bool = true
      for oneElementservice in service {
          if (!oneElementservice.isInitialized()) {
              isInitservice = false
              break 
          }
      }
      if !isInitservice {
       return isInitservice
       }
      var isInitextension_:Bool = true
      for oneElementextension_ in extension_ {
          if (!oneElementextension_.isInitialized()) {
              isInitextension_ = false
              break 
          }
      }
      if !isInitextension_ {
       return isInitextension_
       }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasName {
        output.writeString(1, value:name)
      }
      if hasPackage {
        output.writeString(2, value:package)
      }
      if !dependency.isEmpty {
        for oneValuedependency in dependency {
          output.writeString(3, value:oneValuedependency)
        }
      }
      for oneElementmessageType in messageType {
          output.writeMessage(4, value:oneElementmessageType)
      }
      for oneElementenumType in enumType {
          output.writeMessage(5, value:oneElementenumType)
      }
      for oneElementservice in service {
          output.writeMessage(6, value:oneElementservice)
      }
      for oneElementextension_ in extension_ {
          output.writeMessage(7, value:oneElementextension_)
      }
      if hasOptions {
        output.writeMessage(8, value:options)
      }
      if hasSourceCodeInfo {
        output.writeMessage(9, value:sourceCodeInfo)
      }
      if !publicDependency.isEmpty {
        for oneValuepublicDependency in publicDependency {
          output.writeInt32(10, value:oneValuepublicDependency)
        }
      }
      if !weakDependency.isEmpty {
        for oneValueweakDependency in weakDependency {
          output.writeInt32(11, value:oneValueweakDependency)
        }
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      if hasPackage {
        serialize_size += package.computeStringSize(2)
      }
      var dataSizeDependency:Int32 = 0
      for oneValuedependency in dependency {
          dataSizeDependency += oneValuedependency.computeStringSizeNoTag()
      }
      serialize_size += dataSizeDependency
      serialize_size += 1 * Int32(dependency.count)
      for oneElementmessageType in messageType {
          serialize_size += oneElementmessageType.computeMessageSize(4)
      }
      for oneElementenumType in enumType {
          serialize_size += oneElementenumType.computeMessageSize(5)
      }
      for oneElementservice in service {
          serialize_size += oneElementservice.computeMessageSize(6)
      }
      for oneElementextension_ in extension_ {
          serialize_size += oneElementextension_.computeMessageSize(7)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(8) {
              serialize_size += varSizeoptions
          }
      }
      if hasSourceCodeInfo {
          if let varSizesourceCodeInfo = sourceCodeInfo?.computeMessageSize(9) {
              serialize_size += varSizesourceCodeInfo
          }
      }
      var dataSizePublicDependency:Int32 = 0
      for oneValuepublicDependency in publicDependency {
          dataSizePublicDependency += oneValuepublicDependency.computeInt32SizeNoTag()
      }
      serialize_size += dataSizePublicDependency
      serialize_size += 1 * Int32(publicDependency.count)
      var dataSizeWeakDependency:Int32 = 0
      for oneValueweakDependency in weakDependency {
          dataSizeWeakDependency += oneValueweakDependency.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeWeakDependency
      serialize_size += 1 * Int32(weakDependency.count)
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> FileDescriptorProto {
      return FileDescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> FileDescriptorProto {
      return FileDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> FileDescriptorProto {
      return FileDescriptorProto.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FileDescriptorProto {
      return FileDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> FileDescriptorProto {
      return FileDescriptorProto.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FileDescriptorProto {
      return FileDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> FileDescriptorProtoBuilder {
      return FileDescriptorProto.classBuilder() as! FileDescriptorProtoBuilder
    }
    public func builder() -> FileDescriptorProtoBuilder {
      return classBuilder() as! FileDescriptorProtoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return FileDescriptorProtoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return FileDescriptorProto.builder()
    }
    public func toBuilder() -> FileDescriptorProtoBuilder {
      return FileDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:FileDescriptorProto) -> FileDescriptorProtoBuilder {
      return FileDescriptorProto.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasPackage {
        output += "\(indent) package: \(package) \n"
      }
      var dependencyElementIndex:Int = 0
      for oneValuedependency in dependency  {
          output += "\(indent) dependency[\(dependencyElementIndex)]: \(oneValuedependency)\n"
          dependencyElementIndex++
      }
      var messageTypeElementIndex:Int = 0
      for oneElementmessageType in messageType {
          output += "\(indent) messageType[\(messageTypeElementIndex)] {\n"
          oneElementmessageType.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          messageTypeElementIndex++
      }
      var enumTypeElementIndex:Int = 0
      for oneElementenumType in enumType {
          output += "\(indent) enumType[\(enumTypeElementIndex)] {\n"
          oneElementenumType.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          enumTypeElementIndex++
      }
      var serviceElementIndex:Int = 0
      for oneElementservice in service {
          output += "\(indent) service[\(serviceElementIndex)] {\n"
          oneElementservice.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          serviceElementIndex++
      }
      var extension_ElementIndex:Int = 0
      for oneElementextension_ in extension_ {
          output += "\(indent) extension_[\(extension_ElementIndex)] {\n"
          oneElementextension_.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          extension_ElementIndex++
      }
      if hasOptions {
        output += "\(indent) options {\n"
        options?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasSourceCodeInfo {
        output += "\(indent) sourceCodeInfo {\n"
        sourceCodeInfo?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      var publicDependencyElementIndex:Int = 0
      for oneValuepublicDependency in publicDependency  {
          output += "\(indent) publicDependency[\(publicDependencyElementIndex)]: \(oneValuepublicDependency)\n"
          publicDependencyElementIndex++
      }
      var weakDependencyElementIndex:Int = 0
      for oneValueweakDependency in weakDependency  {
          output += "\(indent) weakDependency[\(weakDependencyElementIndex)]: \(oneValueweakDependency)\n"
          weakDependencyElementIndex++
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasPackage {
               hashCode = (hashCode &* 31) &+ package.hashValue
            }
            for oneValuedependency in dependency {
                hashCode = (hashCode &* 31) &+ oneValuedependency.hashValue
            }
            for oneElementmessageType in messageType {
                hashCode = (hashCode &* 31) &+ oneElementmessageType.hashValue
            }
            for oneElementenumType in enumType {
                hashCode = (hashCode &* 31) &+ oneElementenumType.hashValue
            }
            for oneElementservice in service {
                hashCode = (hashCode &* 31) &+ oneElementservice.hashValue
            }
            for oneElementextension_ in extension_ {
                hashCode = (hashCode &* 31) &+ oneElementextension_.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            if hasSourceCodeInfo {
                if let hashValuesourceCodeInfo = sourceCodeInfo?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesourceCodeInfo
                }
            }
            for oneValuepublicDependency in publicDependency {
                hashCode = (hashCode &* 31) &+ oneValuepublicDependency.hashValue
            }
            for oneValueweakDependency in weakDependency {
                hashCode = (hashCode &* 31) &+ oneValueweakDependency.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "FileDescriptorProto"
    }
    override public func className() -> String {
        return "FileDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return FileDescriptorProto.self
    }
    //Meta information declaration end

  }

  final public class FileDescriptorProtoBuilder : GeneratedMessageBuilder {
    private var builderResult:FileDescriptorProto

    required override public init () {
       builderResult = FileDescriptorProto()
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> FileDescriptorProtoBuilder {
      self.name = value
      return self
    }
    public func clearName() -> FileDescriptorProtoBuilder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasPackage:Bool {
         get {
              return builderResult.hasPackage
         }
    }
    public var package:String {
         get {
              return builderResult.package
         }
         set (value) {
             builderResult.hasPackage = true
             builderResult.package = value
         }
    }
    public func setPackage(value:String)-> FileDescriptorProtoBuilder {
      self.package = value
      return self
    }
    public func clearPackage() -> FileDescriptorProtoBuilder{
         builderResult.hasPackage = false
         builderResult.package = ""
         return self
    }
    public var dependency:Array<String> {
         get {
             return builderResult.dependency
         }
         set (array) {
             builderResult.dependency = array
         }
    }
    public func setDependency(value:Array<String>)-> FileDescriptorProtoBuilder {
      self.dependency = value
      return self
    }
    public func clearDependency() -> FileDescriptorProtoBuilder {
       builderResult.dependency.removeAll(keepCapacity: false)
       return self
    }
    public var publicDependency:Array<Int32> {
         get {
             return builderResult.publicDependency
         }
         set (array) {
             builderResult.publicDependency = array
         }
    }
    public func setPublicDependency(value:Array<Int32>)-> FileDescriptorProtoBuilder {
      self.publicDependency = value
      return self
    }
    public func clearPublicDependency() -> FileDescriptorProtoBuilder {
       builderResult.publicDependency.removeAll(keepCapacity: false)
       return self
    }
    public var weakDependency:Array<Int32> {
         get {
             return builderResult.weakDependency
         }
         set (array) {
             builderResult.weakDependency = array
         }
    }
    public func setWeakDependency(value:Array<Int32>)-> FileDescriptorProtoBuilder {
      self.weakDependency = value
      return self
    }
    public func clearWeakDependency() -> FileDescriptorProtoBuilder {
       builderResult.weakDependency.removeAll(keepCapacity: false)
       return self
    }
    public var messageType:Array<DescriptorProto> {
         get {
             return builderResult.messageType
         }
         set (value) {
             builderResult.messageType = value
         }
    }
    public func setMessageType(value:Array<DescriptorProto>)-> DescriptorProtoBuilder {
      self.messageType = value
      return self
    }
    public func clearMessageType() -> DescriptorProtoBuilder {
      builderResult.messageType.removeAll(keepCapacity: false)
      return self
    }
    public var enumType:Array<EnumDescriptorProto> {
         get {
             return builderResult.enumType
         }
         set (value) {
             builderResult.enumType = value
         }
    }
    public func setEnumType(value:Array<EnumDescriptorProto>)-> EnumDescriptorProtoBuilder {
      self.enumType = value
      return self
    }
    public func clearEnumType() -> EnumDescriptorProtoBuilder {
      builderResult.enumType.removeAll(keepCapacity: false)
      return self
    }
    public var service:Array<ServiceDescriptorProto> {
         get {
             return builderResult.service
         }
         set (value) {
             builderResult.service = value
         }
    }
    public func setService(value:Array<ServiceDescriptorProto>)-> ServiceDescriptorProtoBuilder {
      self.service = value
      return self
    }
    public func clearService() -> ServiceDescriptorProtoBuilder {
      builderResult.service.removeAll(keepCapacity: false)
      return self
    }
    public var extension_:Array<FieldDescriptorProto> {
         get {
             return builderResult.extension_
         }
         set (value) {
             builderResult.extension_ = value
         }
    }
    public func setExtension(value:Array<FieldDescriptorProto>)-> FieldDescriptorProtoBuilder {
      self.extension_ = value
      return self
    }
    public func clearExtension() -> FieldDescriptorProtoBuilder {
      builderResult.extension_.removeAll(keepCapacity: false)
      return self
    }
    public var hasOptions:Bool {
         get {
             return builderResult.hasOptions
         }
    }
    public var options:FileOptions! {
         get {
             return builderResult.options
         }
         set (value) {
             builderResult.hasOptions = true
             builderResult.options = value
         }
    }
    public func setOptions(value:FileOptions!)-> FileOptionsBuilder {
      self.options = value
      return self
    }
    public func mergeOptions(value:FileOptions) -> FileOptionsBuilder {
      if (builderResult.hasOptions) {
        builderResult.options = FileOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
      } else {
        builderResult.options = value
      }
      builderResult.hasOptions = true
      return self
    }
    public func clearOptions() -> FileOptionsBuilder {
      builderResult.hasOptions = false
      builderResult.options = nil
      return self
    }
    public var hasSourceCodeInfo:Bool {
         get {
             return builderResult.hasSourceCodeInfo
         }
    }
    public var sourceCodeInfo:SourceCodeInfo! {
         get {
             return builderResult.sourceCodeInfo
         }
         set (value) {
             builderResult.hasSourceCodeInfo = true
             builderResult.sourceCodeInfo = value
         }
    }
    public func setSourceCodeInfo(value:SourceCodeInfo!)-> SourceCodeInfoBuilder {
      self.sourceCodeInfo = value
      return self
    }
    public func mergeSourceCodeInfo(value:SourceCodeInfo) -> SourceCodeInfoBuilder {
      if (builderResult.hasSourceCodeInfo) {
        builderResult.sourceCodeInfo = SourceCodeInfo.builderWithPrototype(builderResult.sourceCodeInfo).mergeFrom(value).buildPartial()
      } else {
        builderResult.sourceCodeInfo = value
      }
      builderResult.hasSourceCodeInfo = true
      return self
    }
    public func clearSourceCodeInfo() -> SourceCodeInfoBuilder {
      builderResult.hasSourceCodeInfo = false
      builderResult.sourceCodeInfo = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> FileDescriptorProtoBuilder {
      builderResult = FileDescriptorProto()
      return self
    }
    public override func clone() -> FileDescriptorProtoBuilder {
      return FileDescriptorProto.builderWithPrototype(builderResult)
    }
    public override func build() -> FileDescriptorProto {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> FileDescriptorProto {
      var returnMe:FileDescriptorProto = builderResult
      return returnMe
    }
    public func mergeFrom(other:FileDescriptorProto) -> FileDescriptorProtoBuilder {
      if (other == FileDescriptorProto()) {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if other.hasPackage {
           package = other.package
      }
      if !other.dependency.isEmpty {
          builderResult.dependency += other.dependency
      }
      if !other.publicDependency.isEmpty {
          builderResult.publicDependency += other.publicDependency
      }
      if !other.weakDependency.isEmpty {
          builderResult.weakDependency += other.weakDependency
      }
      if !other.messageType.isEmpty  {
         builderResult.messageType += other.messageType
      }
      if !other.enumType.isEmpty  {
         builderResult.enumType += other.enumType
      }
      if !other.service.isEmpty  {
         builderResult.service += other.service
      }
      if !other.extension_.isEmpty  {
         builderResult.extension_ += other.extension_
      }
      if (other.hasOptions) {
          mergeOptions(other.options)
      }
      if (other.hasSourceCodeInfo) {
          mergeSourceCodeInfo(other.sourceCodeInfo)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->FileDescriptorProtoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FileDescriptorProtoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          name = input.readString()

        case 18 :
          package = input.readString()

        case 26 :
          dependency += [input.readString()]

        case 34 :
          var subBuilder = DescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          messageType += [subBuilder.buildPartial()]

        case 42 :
          var subBuilder = EnumDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          enumType += [subBuilder.buildPartial()]

        case 50 :
          var subBuilder = ServiceDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          service += [subBuilder.buildPartial()]

        case 58 :
          var subBuilder = FieldDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          extension_ += [subBuilder.buildPartial()]

        case 66 :
          var subBuilder:FileOptionsBuilder = FileOptions.builder()
          if hasOptions {
            subBuilder.mergeFrom(options)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          options = subBuilder.buildPartial()

        case 74 :
          var subBuilder:SourceCodeInfoBuilder = SourceCodeInfo.builder()
          if hasSourceCodeInfo {
            subBuilder.mergeFrom(sourceCodeInfo)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          sourceCodeInfo = subBuilder.buildPartial()

        case 80 :
          publicDependency += [input.readInt32()]

        case 88 :
          weakDependency += [input.readInt32()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class DescriptorProto : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class ExtensionRange : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasStart:Bool = false
        public private(set) var start:Int32 = Int32(0)

        public private(set) var hasEnd:Bool = false
        public private(set) var end:Int32 = Int32(0)

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) {
          if hasStart {
            output.writeInt32(1, value:start)
          }
          if hasEnd {
            output.writeInt32(2, value:end)
          }
          unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasStart {
            serialize_size += start.computeInt32Size(1)
          }
          if hasEnd {
            serialize_size += end.computeInt32Size(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseFromData(data:NSData) -> Google.Protobuf.DescriptorProto {
          return Google.Protobuf.DescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.DescriptorProto {
          return Google.Protobuf.DescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) -> Google.Protobuf.DescriptorProto {
          return Google.Protobuf.DescriptorProto.builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Google.Protobuf.DescriptorProto {
          return Google.Protobuf.DescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) -> Google.Protobuf.DescriptorProto {
          return Google.Protobuf.DescriptorProto.builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.DescriptorProto {
          return Google.Protobuf.DescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func builder() -> Google.Protobuf.DescriptorProtoBuilder {
          return Google.Protobuf.DescriptorProto.classBuilder() as! Google.Protobuf.DescriptorProtoBuilder
        }
        public func builder() -> Google.Protobuf.DescriptorProtoBuilder {
          return classBuilder() as! Google.Protobuf.DescriptorProtoBuilder
        }
        public override class func classBuilder() -> MessageBuilder {
          return Google.Protobuf.DescriptorProtoBuilder()
        }
        public override func classBuilder() -> MessageBuilder {
          return Google.Protobuf.DescriptorProto.builder()
        }
        public func toBuilder() -> Google.Protobuf.DescriptorProtoBuilder {
          return Google.Protobuf.DescriptorProto.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.DescriptorProto) -> Google.Protobuf.DescriptorProtoBuilder {
          return Google.Protobuf.DescriptorProto.builder().mergeFrom(prototype)
        }
        override public func writeDescriptionTo(inout output:String, indent:String) {
          if hasStart {
            output += "\(indent) start: \(start) \n"
          }
          if hasEnd {
            output += "\(indent) end: \(end) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStart {
                   hashCode = (hashCode &* 31) &+ start.hashValue
                }
                if hasEnd {
                   hashCode = (hashCode &* 31) &+ end.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.DescriptorProto"
        }
        override public func className() -> String {
            return "Google.Protobuf.DescriptorProto"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Google.Protobuf.DescriptorProto.self
        }
        //Meta information declaration end

      }

      final public class ExtensionRangeBuilder : GeneratedMessageBuilder {
        private var builderResult:Google.Protobuf.DescriptorProto

        required override public init () {
           builderResult = Google.Protobuf.DescriptorProto()
           super.init()
        }
        public var hasStart:Bool {
             get {
                  return builderResult.hasStart
             }
        }
        public var start:Int32 {
             get {
                  return builderResult.start
             }
             set (value) {
                 builderResult.hasStart = true
                 builderResult.start = value
             }
        }
        public func setStart(value:Int32)-> ExtensionRangeBuilder {
          self.start = value
          return self
        }
        public func clearStart() -> ExtensionRangeBuilder{
             builderResult.hasStart = false
             builderResult.start = Int32(0)
             return self
        }
        public var hasEnd:Bool {
             get {
                  return builderResult.hasEnd
             }
        }
        public var end:Int32 {
             get {
                  return builderResult.end
             }
             set (value) {
                 builderResult.hasEnd = true
                 builderResult.end = value
             }
        }
        public func setEnd(value:Int32)-> ExtensionRangeBuilder {
          self.end = value
          return self
        }
        public func clearEnd() -> ExtensionRangeBuilder{
             builderResult.hasEnd = false
             builderResult.end = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> Google.Protobuf.DescriptorProtoBuilder {
          builderResult = Google.Protobuf.DescriptorProto()
          return self
        }
        public override func clone() -> Google.Protobuf.DescriptorProtoBuilder {
          return Google.Protobuf.DescriptorProto.builderWithPrototype(builderResult)
        }
        public override func build() -> Google.Protobuf.DescriptorProto {
             checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> Google.Protobuf.DescriptorProto {
          var returnMe:Google.Protobuf.DescriptorProto = builderResult
          return returnMe
        }
        public func mergeFrom(other:Google.Protobuf.DescriptorProto) -> Google.Protobuf.DescriptorProtoBuilder {
          if (other == Google.Protobuf.DescriptorProto()) {
           return self
          }
          if other.hasStart {
               start = other.start
          }
          if other.hasEnd {
               end = other.end
          }
          mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) ->Google.Protobuf.DescriptorProtoBuilder {
             return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.DescriptorProtoBuilder {
          var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            var tag = input.readTag()
            switch tag {
            case 0: 
              self.unknownFields = unknownFieldsBuilder.build()
              return self

            case 8 :
              start = input.readInt32()

            case 16 :
              end = input.readInt32()

            default:
              if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                 unknownFields = unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    //Nested type declaration end

    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasOptions:Bool = false
    public private(set) var options:MessageOptions!
    public private(set) var field:Array<FieldDescriptorProto>  = Array<FieldDescriptorProto>()
    public private(set) var extension_:Array<FieldDescriptorProto>  = Array<FieldDescriptorProto>()
    public private(set) var nestedType:Array<DescriptorProto>  = Array<DescriptorProto>()
    public private(set) var enumType:Array<EnumDescriptorProto>  = Array<EnumDescriptorProto>()
    public private(set) var extensionRange:Array<Google.Protobuf.DescriptorProto>  = Array<Google.Protobuf.DescriptorProto>()
    public private(set) var oneofDecl:Array<OneofDescriptorProto>  = Array<OneofDescriptorProto>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitfield:Bool = true
      for oneElementfield in field {
          if (!oneElementfield.isInitialized()) {
              isInitfield = false
              break 
          }
      }
      if !isInitfield {
       return isInitfield
       }
      var isInitextension_:Bool = true
      for oneElementextension_ in extension_ {
          if (!oneElementextension_.isInitialized()) {
              isInitextension_ = false
              break 
          }
      }
      if !isInitextension_ {
       return isInitextension_
       }
      var isInitnestedType:Bool = true
      for oneElementnestedType in nestedType {
          if (!oneElementnestedType.isInitialized()) {
              isInitnestedType = false
              break 
          }
      }
      if !isInitnestedType {
       return isInitnestedType
       }
      var isInitenumType:Bool = true
      for oneElementenumType in enumType {
          if (!oneElementenumType.isInitialized()) {
              isInitenumType = false
              break 
          }
      }
      if !isInitenumType {
       return isInitenumType
       }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasName {
        output.writeString(1, value:name)
      }
      for oneElementfield in field {
          output.writeMessage(2, value:oneElementfield)
      }
      for oneElementnestedType in nestedType {
          output.writeMessage(3, value:oneElementnestedType)
      }
      for oneElementenumType in enumType {
          output.writeMessage(4, value:oneElementenumType)
      }
      for oneElementextensionRange in extensionRange {
          output.writeMessage(5, value:oneElementextensionRange)
      }
      for oneElementextension_ in extension_ {
          output.writeMessage(6, value:oneElementextension_)
      }
      if hasOptions {
        output.writeMessage(7, value:options)
      }
      for oneElementoneofDecl in oneofDecl {
          output.writeMessage(8, value:oneElementoneofDecl)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      for oneElementfield in field {
          serialize_size += oneElementfield.computeMessageSize(2)
      }
      for oneElementnestedType in nestedType {
          serialize_size += oneElementnestedType.computeMessageSize(3)
      }
      for oneElementenumType in enumType {
          serialize_size += oneElementenumType.computeMessageSize(4)
      }
      for oneElementextensionRange in extensionRange {
          serialize_size += oneElementextensionRange.computeMessageSize(5)
      }
      for oneElementextension_ in extension_ {
          serialize_size += oneElementextension_.computeMessageSize(6)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(7) {
              serialize_size += varSizeoptions
          }
      }
      for oneElementoneofDecl in oneofDecl {
          serialize_size += oneElementoneofDecl.computeMessageSize(8)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> DescriptorProto {
      return DescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> DescriptorProto {
      return DescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> DescriptorProto {
      return DescriptorProto.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->DescriptorProto {
      return DescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> DescriptorProto {
      return DescriptorProto.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DescriptorProto {
      return DescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> DescriptorProtoBuilder {
      return DescriptorProto.classBuilder() as! DescriptorProtoBuilder
    }
    public func builder() -> DescriptorProtoBuilder {
      return classBuilder() as! DescriptorProtoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return DescriptorProtoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return DescriptorProto.builder()
    }
    public func toBuilder() -> DescriptorProtoBuilder {
      return DescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:DescriptorProto) -> DescriptorProtoBuilder {
      return DescriptorProto.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var fieldElementIndex:Int = 0
      for oneElementfield in field {
          output += "\(indent) field[\(fieldElementIndex)] {\n"
          oneElementfield.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          fieldElementIndex++
      }
      var nestedTypeElementIndex:Int = 0
      for oneElementnestedType in nestedType {
          output += "\(indent) nestedType[\(nestedTypeElementIndex)] {\n"
          oneElementnestedType.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          nestedTypeElementIndex++
      }
      var enumTypeElementIndex:Int = 0
      for oneElementenumType in enumType {
          output += "\(indent) enumType[\(enumTypeElementIndex)] {\n"
          oneElementenumType.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          enumTypeElementIndex++
      }
      var extensionRangeElementIndex:Int = 0
      for oneElementextensionRange in extensionRange {
          output += "\(indent) extensionRange[\(extensionRangeElementIndex)] {\n"
          oneElementextensionRange.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          extensionRangeElementIndex++
      }
      var extension_ElementIndex:Int = 0
      for oneElementextension_ in extension_ {
          output += "\(indent) extension_[\(extension_ElementIndex)] {\n"
          oneElementextension_.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          extension_ElementIndex++
      }
      if hasOptions {
        output += "\(indent) options {\n"
        options?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      var oneofDeclElementIndex:Int = 0
      for oneElementoneofDecl in oneofDecl {
          output += "\(indent) oneofDecl[\(oneofDeclElementIndex)] {\n"
          oneElementoneofDecl.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          oneofDeclElementIndex++
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementfield in field {
                hashCode = (hashCode &* 31) &+ oneElementfield.hashValue
            }
            for oneElementnestedType in nestedType {
                hashCode = (hashCode &* 31) &+ oneElementnestedType.hashValue
            }
            for oneElementenumType in enumType {
                hashCode = (hashCode &* 31) &+ oneElementenumType.hashValue
            }
            for oneElementextensionRange in extensionRange {
                hashCode = (hashCode &* 31) &+ oneElementextensionRange.hashValue
            }
            for oneElementextension_ in extension_ {
                hashCode = (hashCode &* 31) &+ oneElementextension_.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            for oneElementoneofDecl in oneofDecl {
                hashCode = (hashCode &* 31) &+ oneElementoneofDecl.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "DescriptorProto"
    }
    override public func className() -> String {
        return "DescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return DescriptorProto.self
    }
    //Meta information declaration end

  }

  final public class DescriptorProtoBuilder : GeneratedMessageBuilder {
    private var builderResult:DescriptorProto

    required override public init () {
       builderResult = DescriptorProto()
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> DescriptorProtoBuilder {
      self.name = value
      return self
    }
    public func clearName() -> DescriptorProtoBuilder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var field:Array<FieldDescriptorProto> {
         get {
             return builderResult.field
         }
         set (value) {
             builderResult.field = value
         }
    }
    public func setField(value:Array<FieldDescriptorProto>)-> FieldDescriptorProtoBuilder {
      self.field = value
      return self
    }
    public func clearField() -> FieldDescriptorProtoBuilder {
      builderResult.field.removeAll(keepCapacity: false)
      return self
    }
    public var extension_:Array<FieldDescriptorProto> {
         get {
             return builderResult.extension_
         }
         set (value) {
             builderResult.extension_ = value
         }
    }
    public func setExtension(value:Array<FieldDescriptorProto>)-> FieldDescriptorProtoBuilder {
      self.extension_ = value
      return self
    }
    public func clearExtension() -> FieldDescriptorProtoBuilder {
      builderResult.extension_.removeAll(keepCapacity: false)
      return self
    }
    public var nestedType:Array<DescriptorProto> {
         get {
             return builderResult.nestedType
         }
         set (value) {
             builderResult.nestedType = value
         }
    }
    public func setNestedType(value:Array<DescriptorProto>)-> DescriptorProtoBuilder {
      self.nestedType = value
      return self
    }
    public func clearNestedType() -> DescriptorProtoBuilder {
      builderResult.nestedType.removeAll(keepCapacity: false)
      return self
    }
    public var enumType:Array<EnumDescriptorProto> {
         get {
             return builderResult.enumType
         }
         set (value) {
             builderResult.enumType = value
         }
    }
    public func setEnumType(value:Array<EnumDescriptorProto>)-> EnumDescriptorProtoBuilder {
      self.enumType = value
      return self
    }
    public func clearEnumType() -> EnumDescriptorProtoBuilder {
      builderResult.enumType.removeAll(keepCapacity: false)
      return self
    }
    public var extensionRange:Array<Google.Protobuf.DescriptorProto> {
         get {
             return builderResult.extensionRange
         }
         set (value) {
             builderResult.extensionRange = value
         }
    }
    public func setExtensionRange(value:Array<Google.Protobuf.DescriptorProto>)-> Google.Protobuf.DescriptorProtoBuilder {
      self.extensionRange = value
      return self
    }
    public func clearExtensionRange() -> Google.Protobuf.DescriptorProtoBuilder {
      builderResult.extensionRange.removeAll(keepCapacity: false)
      return self
    }
    public var oneofDecl:Array<OneofDescriptorProto> {
         get {
             return builderResult.oneofDecl
         }
         set (value) {
             builderResult.oneofDecl = value
         }
    }
    public func setOneofDecl(value:Array<OneofDescriptorProto>)-> OneofDescriptorProtoBuilder {
      self.oneofDecl = value
      return self
    }
    public func clearOneofDecl() -> OneofDescriptorProtoBuilder {
      builderResult.oneofDecl.removeAll(keepCapacity: false)
      return self
    }
    public var hasOptions:Bool {
         get {
             return builderResult.hasOptions
         }
    }
    public var options:MessageOptions! {
         get {
             return builderResult.options
         }
         set (value) {
             builderResult.hasOptions = true
             builderResult.options = value
         }
    }
    public func setOptions(value:MessageOptions!)-> MessageOptionsBuilder {
      self.options = value
      return self
    }
    public func mergeOptions(value:MessageOptions) -> MessageOptionsBuilder {
      if (builderResult.hasOptions) {
        builderResult.options = MessageOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
      } else {
        builderResult.options = value
      }
      builderResult.hasOptions = true
      return self
    }
    public func clearOptions() -> MessageOptionsBuilder {
      builderResult.hasOptions = false
      builderResult.options = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DescriptorProtoBuilder {
      builderResult = DescriptorProto()
      return self
    }
    public override func clone() -> DescriptorProtoBuilder {
      return DescriptorProto.builderWithPrototype(builderResult)
    }
    public override func build() -> DescriptorProto {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DescriptorProto {
      var returnMe:DescriptorProto = builderResult
      return returnMe
    }
    public func mergeFrom(other:DescriptorProto) -> DescriptorProtoBuilder {
      if (other == DescriptorProto()) {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if !other.field.isEmpty  {
         builderResult.field += other.field
      }
      if !other.extension_.isEmpty  {
         builderResult.extension_ += other.extension_
      }
      if !other.nestedType.isEmpty  {
         builderResult.nestedType += other.nestedType
      }
      if !other.enumType.isEmpty  {
         builderResult.enumType += other.enumType
      }
      if !other.extensionRange.isEmpty  {
         builderResult.extensionRange += other.extensionRange
      }
      if !other.oneofDecl.isEmpty  {
         builderResult.oneofDecl += other.oneofDecl
      }
      if (other.hasOptions) {
          mergeOptions(other.options)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->DescriptorProtoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DescriptorProtoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          name = input.readString()

        case 18 :
          var subBuilder = FieldDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          field += [subBuilder.buildPartial()]

        case 26 :
          var subBuilder = DescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          nestedType += [subBuilder.buildPartial()]

        case 34 :
          var subBuilder = EnumDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          enumType += [subBuilder.buildPartial()]

        case 42 :
          var subBuilder = Google.Protobuf.DescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          extensionRange += [subBuilder.buildPartial()]

        case 50 :
          var subBuilder = FieldDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          extension_ += [subBuilder.buildPartial()]

        case 58 :
          var subBuilder:MessageOptionsBuilder = MessageOptions.builder()
          if hasOptions {
            subBuilder.mergeFrom(options)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          options = subBuilder.buildPartial()

        case 66 :
          var subBuilder = OneofDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          oneofDecl += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class FieldDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Types:Int32 {
        case TypeDouble = 1
        case TypeFloat = 2
        case TypeInt64 = 3
        case TypeUint64 = 4
        case TypeInt32 = 5
        case TypeFixed64 = 6
        case TypeFixed32 = 7
        case TypeBool = 8
        case TypeString = 9
        case TypeGroup = 10
        case TypeMessage = 11
        case TypeBytes = 12
        case TypeUint32 = 13
        case TypeEnum = 14
        case TypeSfixed32 = 15
        case TypeSfixed64 = 16
        case TypeSint32 = 17
        case TypeSint64 = 18

      }

      //Enum type declaration end 



      //Enum type declaration start 

      public enum Label:Int32 {
        case LabelOptional = 1
        case LabelRequired = 2
        case LabelRepeated = 3

      }

      //Enum type declaration end 

    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasNumber:Bool = false
    public private(set) var number:Int32 = Int32(0)

    public private(set) var label:Google.Protobuf.FieldDescriptorProto = Google.Protobuf.FieldDescriptorProto.LabelOptional
    public private(set) var hasLabel:Bool = false
    public private(set) var types:Google.Protobuf.FieldDescriptorProto = Google.Protobuf.FieldDescriptorProto.TypeDouble
    public private(set) var hasTypes:Bool = false
    public private(set) var hasTypeName:Bool = false
    public private(set) var typeName:String = ""

    public private(set) var hasExtendee:Bool = false
    public private(set) var extendee:String = ""

    public private(set) var hasDefaultValue:Bool = false
    public private(set) var defaultValue:String = ""

    public private(set) var hasOneofIndex:Bool = false
    public private(set) var oneofIndex:Int32 = Int32(0)

    public private(set) var hasOptions:Bool = false
    public private(set) var options:FieldOptions!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasName {
        output.writeString(1, value:name)
      }
      if hasExtendee {
        output.writeString(2, value:extendee)
      }
      if hasNumber {
        output.writeInt32(3, value:number)
      }
      if hasLabel {
        output.writeEnum(4, value:label.rawValue)
      }
      if hasTypes {
        output.writeEnum(5, value:types.rawValue)
      }
      if hasTypeName {
        output.writeString(6, value:typeName)
      }
      if hasDefaultValue {
        output.writeString(7, value:defaultValue)
      }
      if hasOptions {
        output.writeMessage(8, value:options)
      }
      if hasOneofIndex {
        output.writeInt32(9, value:oneofIndex)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      if hasExtendee {
        serialize_size += extendee.computeStringSize(2)
      }
      if hasNumber {
        serialize_size += number.computeInt32Size(3)
      }
      if (hasLabel) {
        serialize_size += label.rawValue.computeEnumSize(4)
      }
      if (hasTypes) {
        serialize_size += types.rawValue.computeEnumSize(5)
      }
      if hasTypeName {
        serialize_size += typeName.computeStringSize(6)
      }
      if hasDefaultValue {
        serialize_size += defaultValue.computeStringSize(7)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(8) {
              serialize_size += varSizeoptions
          }
      }
      if hasOneofIndex {
        serialize_size += oneofIndex.computeInt32Size(9)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> FieldDescriptorProto {
      return FieldDescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> FieldDescriptorProto {
      return FieldDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> FieldDescriptorProto {
      return FieldDescriptorProto.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FieldDescriptorProto {
      return FieldDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> FieldDescriptorProto {
      return FieldDescriptorProto.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FieldDescriptorProto {
      return FieldDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> FieldDescriptorProtoBuilder {
      return FieldDescriptorProto.classBuilder() as! FieldDescriptorProtoBuilder
    }
    public func builder() -> FieldDescriptorProtoBuilder {
      return classBuilder() as! FieldDescriptorProtoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return FieldDescriptorProtoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return FieldDescriptorProto.builder()
    }
    public func toBuilder() -> FieldDescriptorProtoBuilder {
      return FieldDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:FieldDescriptorProto) -> FieldDescriptorProtoBuilder {
      return FieldDescriptorProto.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasExtendee {
        output += "\(indent) extendee: \(extendee) \n"
      }
      if hasNumber {
        output += "\(indent) number: \(number) \n"
      }
      if (hasLabel) {
        output += "\(indent) label: \(label.rawValue)\n"
      }
      if (hasTypes) {
        output += "\(indent) types: \(types.rawValue)\n"
      }
      if hasTypeName {
        output += "\(indent) typeName: \(typeName) \n"
      }
      if hasDefaultValue {
        output += "\(indent) defaultValue: \(defaultValue) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        options?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasOneofIndex {
        output += "\(indent) oneofIndex: \(oneofIndex) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasExtendee {
               hashCode = (hashCode &* 31) &+ extendee.hashValue
            }
            if hasNumber {
               hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasLabel {
               hashCode = (hashCode &* 31) &+ Int(label.rawValue)
            }
            if hasTypes {
               hashCode = (hashCode &* 31) &+ Int(types.rawValue)
            }
            if hasTypeName {
               hashCode = (hashCode &* 31) &+ typeName.hashValue
            }
            if hasDefaultValue {
               hashCode = (hashCode &* 31) &+ defaultValue.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            if hasOneofIndex {
               hashCode = (hashCode &* 31) &+ oneofIndex.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "FieldDescriptorProto"
    }
    override public func className() -> String {
        return "FieldDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return FieldDescriptorProto.self
    }
    //Meta information declaration end

  }

  final public class FieldDescriptorProtoBuilder : GeneratedMessageBuilder {
    private var builderResult:FieldDescriptorProto

    required override public init () {
       builderResult = FieldDescriptorProto()
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> FieldDescriptorProtoBuilder {
      self.name = value
      return self
    }
    public func clearName() -> FieldDescriptorProtoBuilder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasNumber:Bool {
         get {
              return builderResult.hasNumber
         }
    }
    public var number:Int32 {
         get {
              return builderResult.number
         }
         set (value) {
             builderResult.hasNumber = true
             builderResult.number = value
         }
    }
    public func setNumber(value:Int32)-> FieldDescriptorProtoBuilder {
      self.number = value
      return self
    }
    public func clearNumber() -> FieldDescriptorProtoBuilder{
         builderResult.hasNumber = false
         builderResult.number = Int32(0)
         return self
    }
      public var hasLabel:Bool{
          get {
              return builderResult.hasLabel
          }
      }
      public var label:Google.Protobuf.FieldDescriptorProto {
          get {
              return builderResult.label
          }
          set (value) {
              builderResult.hasLabel = true
              builderResult.label = value
          }
      }
      public func setLabel(value:Google.Protobuf.FieldDescriptorProto)-> Google.Protobuf.FieldDescriptorProtoBuilder {
        self.label = value
        return self
      }
      public func clearLabel() -> Google.Protobuf.FieldDescriptorProtoBuilder {
         builderResult.hasLabel = false
         builderResult.label = .LabelOptional
         return self
      }
      public var hasTypes:Bool{
          get {
              return builderResult.hasTypes
          }
      }
      public var types:Google.Protobuf.FieldDescriptorProto {
          get {
              return builderResult.types
          }
          set (value) {
              builderResult.hasTypes = true
              builderResult.types = value
          }
      }
      public func setTypes(value:Google.Protobuf.FieldDescriptorProto)-> Google.Protobuf.FieldDescriptorProtoBuilder {
        self.types = value
        return self
      }
      public func clearTypes() -> Google.Protobuf.FieldDescriptorProtoBuilder {
         builderResult.hasTypes = false
         builderResult.types = .TypeDouble
         return self
      }
    public var hasTypeName:Bool {
         get {
              return builderResult.hasTypeName
         }
    }
    public var typeName:String {
         get {
              return builderResult.typeName
         }
         set (value) {
             builderResult.hasTypeName = true
             builderResult.typeName = value
         }
    }
    public func setTypeName(value:String)-> FieldDescriptorProtoBuilder {
      self.typeName = value
      return self
    }
    public func clearTypeName() -> FieldDescriptorProtoBuilder{
         builderResult.hasTypeName = false
         builderResult.typeName = ""
         return self
    }
    public var hasExtendee:Bool {
         get {
              return builderResult.hasExtendee
         }
    }
    public var extendee:String {
         get {
              return builderResult.extendee
         }
         set (value) {
             builderResult.hasExtendee = true
             builderResult.extendee = value
         }
    }
    public func setExtendee(value:String)-> FieldDescriptorProtoBuilder {
      self.extendee = value
      return self
    }
    public func clearExtendee() -> FieldDescriptorProtoBuilder{
         builderResult.hasExtendee = false
         builderResult.extendee = ""
         return self
    }
    public var hasDefaultValue:Bool {
         get {
              return builderResult.hasDefaultValue
         }
    }
    public var defaultValue:String {
         get {
              return builderResult.defaultValue
         }
         set (value) {
             builderResult.hasDefaultValue = true
             builderResult.defaultValue = value
         }
    }
    public func setDefaultValue(value:String)-> FieldDescriptorProtoBuilder {
      self.defaultValue = value
      return self
    }
    public func clearDefaultValue() -> FieldDescriptorProtoBuilder{
         builderResult.hasDefaultValue = false
         builderResult.defaultValue = ""
         return self
    }
    public var hasOneofIndex:Bool {
         get {
              return builderResult.hasOneofIndex
         }
    }
    public var oneofIndex:Int32 {
         get {
              return builderResult.oneofIndex
         }
         set (value) {
             builderResult.hasOneofIndex = true
             builderResult.oneofIndex = value
         }
    }
    public func setOneofIndex(value:Int32)-> FieldDescriptorProtoBuilder {
      self.oneofIndex = value
      return self
    }
    public func clearOneofIndex() -> FieldDescriptorProtoBuilder{
         builderResult.hasOneofIndex = false
         builderResult.oneofIndex = Int32(0)
         return self
    }
    public var hasOptions:Bool {
         get {
             return builderResult.hasOptions
         }
    }
    public var options:FieldOptions! {
         get {
             return builderResult.options
         }
         set (value) {
             builderResult.hasOptions = true
             builderResult.options = value
         }
    }
    public func setOptions(value:FieldOptions!)-> FieldOptionsBuilder {
      self.options = value
      return self
    }
    public func mergeOptions(value:FieldOptions) -> FieldOptionsBuilder {
      if (builderResult.hasOptions) {
        builderResult.options = FieldOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
      } else {
        builderResult.options = value
      }
      builderResult.hasOptions = true
      return self
    }
    public func clearOptions() -> FieldOptionsBuilder {
      builderResult.hasOptions = false
      builderResult.options = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> FieldDescriptorProtoBuilder {
      builderResult = FieldDescriptorProto()
      return self
    }
    public override func clone() -> FieldDescriptorProtoBuilder {
      return FieldDescriptorProto.builderWithPrototype(builderResult)
    }
    public override func build() -> FieldDescriptorProto {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> FieldDescriptorProto {
      var returnMe:FieldDescriptorProto = builderResult
      return returnMe
    }
    public func mergeFrom(other:FieldDescriptorProto) -> FieldDescriptorProtoBuilder {
      if (other == FieldDescriptorProto()) {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if other.hasNumber {
           number = other.number
      }
      if other.hasLabel {
           label = other.label
      }
      if other.hasTypes {
           types = other.types
      }
      if other.hasTypeName {
           typeName = other.typeName
      }
      if other.hasExtendee {
           extendee = other.extendee
      }
      if other.hasDefaultValue {
           defaultValue = other.defaultValue
      }
      if other.hasOneofIndex {
           oneofIndex = other.oneofIndex
      }
      if (other.hasOptions) {
          mergeOptions(other.options)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->FieldDescriptorProtoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FieldDescriptorProtoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          name = input.readString()

        case 18 :
          extendee = input.readString()

        case 24 :
          number = input.readInt32()

        case 32 :
          let valueIntlabel = input.readEnum()
          if let enumslabel = Google.Protobuf.FieldDescriptorProto(rawValue:valueIntlabel){
               label = enumslabel
          } else {
               unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntlabel))
          }

        case 40 :
          let valueInttypes = input.readEnum()
          if let enumstypes = Google.Protobuf.FieldDescriptorProto(rawValue:valueInttypes){
               types = enumstypes
          } else {
               unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueInttypes))
          }

        case 50 :
          typeName = input.readString()

        case 58 :
          defaultValue = input.readString()

        case 66 :
          var subBuilder:FieldOptionsBuilder = FieldOptions.builder()
          if hasOptions {
            subBuilder.mergeFrom(options)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          options = subBuilder.buildPartial()

        case 72 :
          oneofIndex = input.readInt32()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class OneofDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasName {
        output.writeString(1, value:name)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> OneofDescriptorProto {
      return OneofDescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> OneofDescriptorProto {
      return OneofDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> OneofDescriptorProto {
      return OneofDescriptorProto.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->OneofDescriptorProto {
      return OneofDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> OneofDescriptorProto {
      return OneofDescriptorProto.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> OneofDescriptorProto {
      return OneofDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> OneofDescriptorProtoBuilder {
      return OneofDescriptorProto.classBuilder() as! OneofDescriptorProtoBuilder
    }
    public func builder() -> OneofDescriptorProtoBuilder {
      return classBuilder() as! OneofDescriptorProtoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return OneofDescriptorProtoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return OneofDescriptorProto.builder()
    }
    public func toBuilder() -> OneofDescriptorProtoBuilder {
      return OneofDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:OneofDescriptorProto) -> OneofDescriptorProtoBuilder {
      return OneofDescriptorProto.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "OneofDescriptorProto"
    }
    override public func className() -> String {
        return "OneofDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return OneofDescriptorProto.self
    }
    //Meta information declaration end

  }

  final public class OneofDescriptorProtoBuilder : GeneratedMessageBuilder {
    private var builderResult:OneofDescriptorProto

    required override public init () {
       builderResult = OneofDescriptorProto()
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> OneofDescriptorProtoBuilder {
      self.name = value
      return self
    }
    public func clearName() -> OneofDescriptorProtoBuilder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> OneofDescriptorProtoBuilder {
      builderResult = OneofDescriptorProto()
      return self
    }
    public override func clone() -> OneofDescriptorProtoBuilder {
      return OneofDescriptorProto.builderWithPrototype(builderResult)
    }
    public override func build() -> OneofDescriptorProto {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> OneofDescriptorProto {
      var returnMe:OneofDescriptorProto = builderResult
      return returnMe
    }
    public func mergeFrom(other:OneofDescriptorProto) -> OneofDescriptorProtoBuilder {
      if (other == OneofDescriptorProto()) {
       return self
      }
      if other.hasName {
           name = other.name
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->OneofDescriptorProtoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> OneofDescriptorProtoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          name = input.readString()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class EnumDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasOptions:Bool = false
    public private(set) var options:EnumOptions!
    public private(set) var value:Array<EnumValueDescriptorProto>  = Array<EnumValueDescriptorProto>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitvalue:Bool = true
      for oneElementvalue in value {
          if (!oneElementvalue.isInitialized()) {
              isInitvalue = false
              break 
          }
      }
      if !isInitvalue {
       return isInitvalue
       }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasName {
        output.writeString(1, value:name)
      }
      for oneElementvalue in value {
          output.writeMessage(2, value:oneElementvalue)
      }
      if hasOptions {
        output.writeMessage(3, value:options)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      for oneElementvalue in value {
          serialize_size += oneElementvalue.computeMessageSize(2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> EnumDescriptorProto {
      return EnumDescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> EnumDescriptorProto {
      return EnumDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> EnumDescriptorProto {
      return EnumDescriptorProto.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->EnumDescriptorProto {
      return EnumDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> EnumDescriptorProto {
      return EnumDescriptorProto.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> EnumDescriptorProto {
      return EnumDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> EnumDescriptorProtoBuilder {
      return EnumDescriptorProto.classBuilder() as! EnumDescriptorProtoBuilder
    }
    public func builder() -> EnumDescriptorProtoBuilder {
      return classBuilder() as! EnumDescriptorProtoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return EnumDescriptorProtoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return EnumDescriptorProto.builder()
    }
    public func toBuilder() -> EnumDescriptorProtoBuilder {
      return EnumDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:EnumDescriptorProto) -> EnumDescriptorProtoBuilder {
      return EnumDescriptorProto.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var valueElementIndex:Int = 0
      for oneElementvalue in value {
          output += "\(indent) value[\(valueElementIndex)] {\n"
          oneElementvalue.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          valueElementIndex++
      }
      if hasOptions {
        output += "\(indent) options {\n"
        options?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementvalue in value {
                hashCode = (hashCode &* 31) &+ oneElementvalue.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "EnumDescriptorProto"
    }
    override public func className() -> String {
        return "EnumDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return EnumDescriptorProto.self
    }
    //Meta information declaration end

  }

  final public class EnumDescriptorProtoBuilder : GeneratedMessageBuilder {
    private var builderResult:EnumDescriptorProto

    required override public init () {
       builderResult = EnumDescriptorProto()
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> EnumDescriptorProtoBuilder {
      self.name = value
      return self
    }
    public func clearName() -> EnumDescriptorProtoBuilder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var value:Array<EnumValueDescriptorProto> {
         get {
             return builderResult.value
         }
         set (value) {
             builderResult.value = value
         }
    }
    public func setValue(value:Array<EnumValueDescriptorProto>)-> EnumValueDescriptorProtoBuilder {
      self.value = value
      return self
    }
    public func clearValue() -> EnumValueDescriptorProtoBuilder {
      builderResult.value.removeAll(keepCapacity: false)
      return self
    }
    public var hasOptions:Bool {
         get {
             return builderResult.hasOptions
         }
    }
    public var options:EnumOptions! {
         get {
             return builderResult.options
         }
         set (value) {
             builderResult.hasOptions = true
             builderResult.options = value
         }
    }
    public func setOptions(value:EnumOptions!)-> EnumOptionsBuilder {
      self.options = value
      return self
    }
    public func mergeOptions(value:EnumOptions) -> EnumOptionsBuilder {
      if (builderResult.hasOptions) {
        builderResult.options = EnumOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
      } else {
        builderResult.options = value
      }
      builderResult.hasOptions = true
      return self
    }
    public func clearOptions() -> EnumOptionsBuilder {
      builderResult.hasOptions = false
      builderResult.options = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EnumDescriptorProtoBuilder {
      builderResult = EnumDescriptorProto()
      return self
    }
    public override func clone() -> EnumDescriptorProtoBuilder {
      return EnumDescriptorProto.builderWithPrototype(builderResult)
    }
    public override func build() -> EnumDescriptorProto {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EnumDescriptorProto {
      var returnMe:EnumDescriptorProto = builderResult
      return returnMe
    }
    public func mergeFrom(other:EnumDescriptorProto) -> EnumDescriptorProtoBuilder {
      if (other == EnumDescriptorProto()) {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if !other.value.isEmpty  {
         builderResult.value += other.value
      }
      if (other.hasOptions) {
          mergeOptions(other.options)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->EnumDescriptorProtoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> EnumDescriptorProtoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          name = input.readString()

        case 18 :
          var subBuilder = EnumValueDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          value += [subBuilder.buildPartial()]

        case 26 :
          var subBuilder:EnumOptionsBuilder = EnumOptions.builder()
          if hasOptions {
            subBuilder.mergeFrom(options)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          options = subBuilder.buildPartial()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class EnumValueDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasNumber:Bool = false
    public private(set) var number:Int32 = Int32(0)

    public private(set) var hasOptions:Bool = false
    public private(set) var options:EnumValueOptions!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasName {
        output.writeString(1, value:name)
      }
      if hasNumber {
        output.writeInt32(2, value:number)
      }
      if hasOptions {
        output.writeMessage(3, value:options)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      if hasNumber {
        serialize_size += number.computeInt32Size(2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> EnumValueDescriptorProto {
      return EnumValueDescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> EnumValueDescriptorProto {
      return EnumValueDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> EnumValueDescriptorProto {
      return EnumValueDescriptorProto.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->EnumValueDescriptorProto {
      return EnumValueDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> EnumValueDescriptorProto {
      return EnumValueDescriptorProto.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> EnumValueDescriptorProto {
      return EnumValueDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> EnumValueDescriptorProtoBuilder {
      return EnumValueDescriptorProto.classBuilder() as! EnumValueDescriptorProtoBuilder
    }
    public func builder() -> EnumValueDescriptorProtoBuilder {
      return classBuilder() as! EnumValueDescriptorProtoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return EnumValueDescriptorProtoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return EnumValueDescriptorProto.builder()
    }
    public func toBuilder() -> EnumValueDescriptorProtoBuilder {
      return EnumValueDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:EnumValueDescriptorProto) -> EnumValueDescriptorProtoBuilder {
      return EnumValueDescriptorProto.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasNumber {
        output += "\(indent) number: \(number) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        options?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasNumber {
               hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "EnumValueDescriptorProto"
    }
    override public func className() -> String {
        return "EnumValueDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return EnumValueDescriptorProto.self
    }
    //Meta information declaration end

  }

  final public class EnumValueDescriptorProtoBuilder : GeneratedMessageBuilder {
    private var builderResult:EnumValueDescriptorProto

    required override public init () {
       builderResult = EnumValueDescriptorProto()
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> EnumValueDescriptorProtoBuilder {
      self.name = value
      return self
    }
    public func clearName() -> EnumValueDescriptorProtoBuilder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasNumber:Bool {
         get {
              return builderResult.hasNumber
         }
    }
    public var number:Int32 {
         get {
              return builderResult.number
         }
         set (value) {
             builderResult.hasNumber = true
             builderResult.number = value
         }
    }
    public func setNumber(value:Int32)-> EnumValueDescriptorProtoBuilder {
      self.number = value
      return self
    }
    public func clearNumber() -> EnumValueDescriptorProtoBuilder{
         builderResult.hasNumber = false
         builderResult.number = Int32(0)
         return self
    }
    public var hasOptions:Bool {
         get {
             return builderResult.hasOptions
         }
    }
    public var options:EnumValueOptions! {
         get {
             return builderResult.options
         }
         set (value) {
             builderResult.hasOptions = true
             builderResult.options = value
         }
    }
    public func setOptions(value:EnumValueOptions!)-> EnumValueOptionsBuilder {
      self.options = value
      return self
    }
    public func mergeOptions(value:EnumValueOptions) -> EnumValueOptionsBuilder {
      if (builderResult.hasOptions) {
        builderResult.options = EnumValueOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
      } else {
        builderResult.options = value
      }
      builderResult.hasOptions = true
      return self
    }
    public func clearOptions() -> EnumValueOptionsBuilder {
      builderResult.hasOptions = false
      builderResult.options = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> EnumValueDescriptorProtoBuilder {
      builderResult = EnumValueDescriptorProto()
      return self
    }
    public override func clone() -> EnumValueDescriptorProtoBuilder {
      return EnumValueDescriptorProto.builderWithPrototype(builderResult)
    }
    public override func build() -> EnumValueDescriptorProto {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EnumValueDescriptorProto {
      var returnMe:EnumValueDescriptorProto = builderResult
      return returnMe
    }
    public func mergeFrom(other:EnumValueDescriptorProto) -> EnumValueDescriptorProtoBuilder {
      if (other == EnumValueDescriptorProto()) {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if other.hasNumber {
           number = other.number
      }
      if (other.hasOptions) {
          mergeOptions(other.options)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->EnumValueDescriptorProtoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> EnumValueDescriptorProtoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          name = input.readString()

        case 16 :
          number = input.readInt32()

        case 26 :
          var subBuilder:EnumValueOptionsBuilder = EnumValueOptions.builder()
          if hasOptions {
            subBuilder.mergeFrom(options)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          options = subBuilder.buildPartial()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ServiceDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasOptions:Bool = false
    public private(set) var options:ServiceOptions!
    public private(set) var method:Array<MethodDescriptorProto>  = Array<MethodDescriptorProto>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitmethod:Bool = true
      for oneElementmethod in method {
          if (!oneElementmethod.isInitialized()) {
              isInitmethod = false
              break 
          }
      }
      if !isInitmethod {
       return isInitmethod
       }
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasName {
        output.writeString(1, value:name)
      }
      for oneElementmethod in method {
          output.writeMessage(2, value:oneElementmethod)
      }
      if hasOptions {
        output.writeMessage(3, value:options)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      for oneElementmethod in method {
          serialize_size += oneElementmethod.computeMessageSize(2)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(3) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> ServiceDescriptorProto {
      return ServiceDescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> ServiceDescriptorProto {
      return ServiceDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> ServiceDescriptorProto {
      return ServiceDescriptorProto.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ServiceDescriptorProto {
      return ServiceDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> ServiceDescriptorProto {
      return ServiceDescriptorProto.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ServiceDescriptorProto {
      return ServiceDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> ServiceDescriptorProtoBuilder {
      return ServiceDescriptorProto.classBuilder() as! ServiceDescriptorProtoBuilder
    }
    public func builder() -> ServiceDescriptorProtoBuilder {
      return classBuilder() as! ServiceDescriptorProtoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return ServiceDescriptorProtoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return ServiceDescriptorProto.builder()
    }
    public func toBuilder() -> ServiceDescriptorProtoBuilder {
      return ServiceDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:ServiceDescriptorProto) -> ServiceDescriptorProtoBuilder {
      return ServiceDescriptorProto.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var methodElementIndex:Int = 0
      for oneElementmethod in method {
          output += "\(indent) method[\(methodElementIndex)] {\n"
          oneElementmethod.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          methodElementIndex++
      }
      if hasOptions {
        output += "\(indent) options {\n"
        options?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneElementmethod in method {
                hashCode = (hashCode &* 31) &+ oneElementmethod.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ServiceDescriptorProto"
    }
    override public func className() -> String {
        return "ServiceDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return ServiceDescriptorProto.self
    }
    //Meta information declaration end

  }

  final public class ServiceDescriptorProtoBuilder : GeneratedMessageBuilder {
    private var builderResult:ServiceDescriptorProto

    required override public init () {
       builderResult = ServiceDescriptorProto()
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> ServiceDescriptorProtoBuilder {
      self.name = value
      return self
    }
    public func clearName() -> ServiceDescriptorProtoBuilder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var method:Array<MethodDescriptorProto> {
         get {
             return builderResult.method
         }
         set (value) {
             builderResult.method = value
         }
    }
    public func setMethod(value:Array<MethodDescriptorProto>)-> MethodDescriptorProtoBuilder {
      self.method = value
      return self
    }
    public func clearMethod() -> MethodDescriptorProtoBuilder {
      builderResult.method.removeAll(keepCapacity: false)
      return self
    }
    public var hasOptions:Bool {
         get {
             return builderResult.hasOptions
         }
    }
    public var options:ServiceOptions! {
         get {
             return builderResult.options
         }
         set (value) {
             builderResult.hasOptions = true
             builderResult.options = value
         }
    }
    public func setOptions(value:ServiceOptions!)-> ServiceOptionsBuilder {
      self.options = value
      return self
    }
    public func mergeOptions(value:ServiceOptions) -> ServiceOptionsBuilder {
      if (builderResult.hasOptions) {
        builderResult.options = ServiceOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
      } else {
        builderResult.options = value
      }
      builderResult.hasOptions = true
      return self
    }
    public func clearOptions() -> ServiceOptionsBuilder {
      builderResult.hasOptions = false
      builderResult.options = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ServiceDescriptorProtoBuilder {
      builderResult = ServiceDescriptorProto()
      return self
    }
    public override func clone() -> ServiceDescriptorProtoBuilder {
      return ServiceDescriptorProto.builderWithPrototype(builderResult)
    }
    public override func build() -> ServiceDescriptorProto {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ServiceDescriptorProto {
      var returnMe:ServiceDescriptorProto = builderResult
      return returnMe
    }
    public func mergeFrom(other:ServiceDescriptorProto) -> ServiceDescriptorProtoBuilder {
      if (other == ServiceDescriptorProto()) {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if !other.method.isEmpty  {
         builderResult.method += other.method
      }
      if (other.hasOptions) {
          mergeOptions(other.options)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->ServiceDescriptorProtoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ServiceDescriptorProtoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          name = input.readString()

        case 18 :
          var subBuilder = MethodDescriptorProto.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          method += [subBuilder.buildPartial()]

        case 26 :
          var subBuilder:ServiceOptionsBuilder = ServiceOptions.builder()
          if hasOptions {
            subBuilder.mergeFrom(options)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          options = subBuilder.buildPartial()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class MethodDescriptorProto : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasInputType:Bool = false
    public private(set) var inputType:String = ""

    public private(set) var hasOutputType:Bool = false
    public private(set) var outputType:String = ""

    public private(set) var hasOptions:Bool = false
    public private(set) var options:MethodOptions!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasOptions {
       if !options.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasName {
        output.writeString(1, value:name)
      }
      if hasInputType {
        output.writeString(2, value:inputType)
      }
      if hasOutputType {
        output.writeString(3, value:outputType)
      }
      if hasOptions {
        output.writeMessage(4, value:options)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasName {
        serialize_size += name.computeStringSize(1)
      }
      if hasInputType {
        serialize_size += inputType.computeStringSize(2)
      }
      if hasOutputType {
        serialize_size += outputType.computeStringSize(3)
      }
      if hasOptions {
          if let varSizeoptions = options?.computeMessageSize(4) {
              serialize_size += varSizeoptions
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> MethodDescriptorProto {
      return MethodDescriptorProto.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> MethodDescriptorProto {
      return MethodDescriptorProto.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> MethodDescriptorProto {
      return MethodDescriptorProto.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MethodDescriptorProto {
      return MethodDescriptorProto.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> MethodDescriptorProto {
      return MethodDescriptorProto.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MethodDescriptorProto {
      return MethodDescriptorProto.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> MethodDescriptorProtoBuilder {
      return MethodDescriptorProto.classBuilder() as! MethodDescriptorProtoBuilder
    }
    public func builder() -> MethodDescriptorProtoBuilder {
      return classBuilder() as! MethodDescriptorProtoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return MethodDescriptorProtoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return MethodDescriptorProto.builder()
    }
    public func toBuilder() -> MethodDescriptorProtoBuilder {
      return MethodDescriptorProto.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:MethodDescriptorProto) -> MethodDescriptorProtoBuilder {
      return MethodDescriptorProto.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasInputType {
        output += "\(indent) inputType: \(inputType) \n"
      }
      if hasOutputType {
        output += "\(indent) outputType: \(outputType) \n"
      }
      if hasOptions {
        output += "\(indent) options {\n"
        options?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasInputType {
               hashCode = (hashCode &* 31) &+ inputType.hashValue
            }
            if hasOutputType {
               hashCode = (hashCode &* 31) &+ outputType.hashValue
            }
            if hasOptions {
                if let hashValueoptions = options?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueoptions
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "MethodDescriptorProto"
    }
    override public func className() -> String {
        return "MethodDescriptorProto"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return MethodDescriptorProto.self
    }
    //Meta information declaration end

  }

  final public class MethodDescriptorProtoBuilder : GeneratedMessageBuilder {
    private var builderResult:MethodDescriptorProto

    required override public init () {
       builderResult = MethodDescriptorProto()
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> MethodDescriptorProtoBuilder {
      self.name = value
      return self
    }
    public func clearName() -> MethodDescriptorProtoBuilder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasInputType:Bool {
         get {
              return builderResult.hasInputType
         }
    }
    public var inputType:String {
         get {
              return builderResult.inputType
         }
         set (value) {
             builderResult.hasInputType = true
             builderResult.inputType = value
         }
    }
    public func setInputType(value:String)-> MethodDescriptorProtoBuilder {
      self.inputType = value
      return self
    }
    public func clearInputType() -> MethodDescriptorProtoBuilder{
         builderResult.hasInputType = false
         builderResult.inputType = ""
         return self
    }
    public var hasOutputType:Bool {
         get {
              return builderResult.hasOutputType
         }
    }
    public var outputType:String {
         get {
              return builderResult.outputType
         }
         set (value) {
             builderResult.hasOutputType = true
             builderResult.outputType = value
         }
    }
    public func setOutputType(value:String)-> MethodDescriptorProtoBuilder {
      self.outputType = value
      return self
    }
    public func clearOutputType() -> MethodDescriptorProtoBuilder{
         builderResult.hasOutputType = false
         builderResult.outputType = ""
         return self
    }
    public var hasOptions:Bool {
         get {
             return builderResult.hasOptions
         }
    }
    public var options:MethodOptions! {
         get {
             return builderResult.options
         }
         set (value) {
             builderResult.hasOptions = true
             builderResult.options = value
         }
    }
    public func setOptions(value:MethodOptions!)-> MethodOptionsBuilder {
      self.options = value
      return self
    }
    public func mergeOptions(value:MethodOptions) -> MethodOptionsBuilder {
      if (builderResult.hasOptions) {
        builderResult.options = MethodOptions.builderWithPrototype(builderResult.options).mergeFrom(value).buildPartial()
      } else {
        builderResult.options = value
      }
      builderResult.hasOptions = true
      return self
    }
    public func clearOptions() -> MethodOptionsBuilder {
      builderResult.hasOptions = false
      builderResult.options = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> MethodDescriptorProtoBuilder {
      builderResult = MethodDescriptorProto()
      return self
    }
    public override func clone() -> MethodDescriptorProtoBuilder {
      return MethodDescriptorProto.builderWithPrototype(builderResult)
    }
    public override func build() -> MethodDescriptorProto {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MethodDescriptorProto {
      var returnMe:MethodDescriptorProto = builderResult
      return returnMe
    }
    public func mergeFrom(other:MethodDescriptorProto) -> MethodDescriptorProtoBuilder {
      if (other == MethodDescriptorProto()) {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if other.hasInputType {
           inputType = other.inputType
      }
      if other.hasOutputType {
           outputType = other.outputType
      }
      if (other.hasOptions) {
          mergeOptions(other.options)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->MethodDescriptorProtoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MethodDescriptorProtoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          name = input.readString()

        case 18 :
          inputType = input.readString()

        case 26 :
          outputType = input.readString()

        case 34 :
          var subBuilder:MethodOptionsBuilder = MethodOptions.builder()
          if hasOptions {
            subBuilder.mergeFrom(options)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          options = subBuilder.buildPartial()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class FileOptions : ExtendableMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum OptimizeMode:Int32 {
        case Speed = 1
        case CodeSize = 2
        case LiteRuntime = 3

      }

      //Enum type declaration end 

    public private(set) var hasJavaPackage:Bool = false
    public private(set) var javaPackage:String = ""

    public private(set) var hasJavaOuterClassname:Bool = false
    public private(set) var javaOuterClassname:String = ""

    public private(set) var hasJavaMultipleFiles:Bool = false
    public private(set) var javaMultipleFiles:Bool = false

    public private(set) var hasJavaGenerateEqualsAndHash:Bool = false
    public private(set) var javaGenerateEqualsAndHash:Bool = false

    public private(set) var hasJavaStringCheckUtf8:Bool = false
    public private(set) var javaStringCheckUtf8:Bool = false

    public private(set) var optimizeFor:Google.Protobuf.FileOptions = Google.Protobuf.FileOptions.Speed
    public private(set) var hasOptimizeFor:Bool = false
    public private(set) var hasGoPackage:Bool = false
    public private(set) var goPackage:String = ""

    public private(set) var hasCcGenericServices:Bool = false
    public private(set) var ccGenericServices:Bool = false

    public private(set) var hasJavaGenericServices:Bool = false
    public private(set) var javaGenericServices:Bool = false

    public private(set) var hasPyGenericServices:Bool = false
    public private(set) var pyGenericServices:Bool = false

    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<UninterpretedOption>  = Array<UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInituninterpretedOption:Bool = true
      for oneElementuninterpretedOption in uninterpretedOption {
          if (!oneElementuninterpretedOption.isInitialized()) {
              isInituninterpretedOption = false
              break 
          }
      }
      if !isInituninterpretedOption {
       return isInituninterpretedOption
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasJavaPackage {
        output.writeString(1, value:javaPackage)
      }
      if hasJavaOuterClassname {
        output.writeString(8, value:javaOuterClassname)
      }
      if hasOptimizeFor {
        output.writeEnum(9, value:optimizeFor.rawValue)
      }
      if hasJavaMultipleFiles {
        output.writeBool(10, value:javaMultipleFiles)
      }
      if hasGoPackage {
        output.writeString(11, value:goPackage)
      }
      if hasCcGenericServices {
        output.writeBool(16, value:ccGenericServices)
      }
      if hasJavaGenericServices {
        output.writeBool(17, value:javaGenericServices)
      }
      if hasPyGenericServices {
        output.writeBool(18, value:pyGenericServices)
      }
      if hasJavaGenerateEqualsAndHash {
        output.writeBool(20, value:javaGenerateEqualsAndHash)
      }
      if hasDeprecated {
        output.writeBool(23, value:deprecated)
      }
      if hasJavaStringCheckUtf8 {
        output.writeBool(27, value:javaStringCheckUtf8)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          output.writeMessage(999, value:oneElementuninterpretedOption)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasJavaPackage {
        serialize_size += javaPackage.computeStringSize(1)
      }
      if hasJavaOuterClassname {
        serialize_size += javaOuterClassname.computeStringSize(8)
      }
      if (hasOptimizeFor) {
        serialize_size += optimizeFor.rawValue.computeEnumSize(9)
      }
      if hasJavaMultipleFiles {
        serialize_size += javaMultipleFiles.computeBoolSize(10)
      }
      if hasGoPackage {
        serialize_size += goPackage.computeStringSize(11)
      }
      if hasCcGenericServices {
        serialize_size += ccGenericServices.computeBoolSize(16)
      }
      if hasJavaGenericServices {
        serialize_size += javaGenericServices.computeBoolSize(17)
      }
      if hasPyGenericServices {
        serialize_size += pyGenericServices.computeBoolSize(18)
      }
      if hasJavaGenerateEqualsAndHash {
        serialize_size += javaGenerateEqualsAndHash.computeBoolSize(20)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(23)
      }
      if hasJavaStringCheckUtf8 {
        serialize_size += javaStringCheckUtf8.computeBoolSize(27)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          serialize_size += oneElementuninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> FileOptions {
      return FileOptions.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> FileOptions {
      return FileOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> FileOptions {
      return FileOptions.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FileOptions {
      return FileOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> FileOptions {
      return FileOptions.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FileOptions {
      return FileOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> FileOptionsBuilder {
      return FileOptions.classBuilder() as! FileOptionsBuilder
    }
    public func builder() -> FileOptionsBuilder {
      return classBuilder() as! FileOptionsBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return FileOptionsBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return FileOptions.builder()
    }
    public func toBuilder() -> FileOptionsBuilder {
      return FileOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:FileOptions) -> FileOptionsBuilder {
      return FileOptions.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasJavaPackage {
        output += "\(indent) javaPackage: \(javaPackage) \n"
      }
      if hasJavaOuterClassname {
        output += "\(indent) javaOuterClassname: \(javaOuterClassname) \n"
      }
      if (hasOptimizeFor) {
        output += "\(indent) optimizeFor: \(optimizeFor.rawValue)\n"
      }
      if hasJavaMultipleFiles {
        output += "\(indent) javaMultipleFiles: \(javaMultipleFiles) \n"
      }
      if hasGoPackage {
        output += "\(indent) goPackage: \(goPackage) \n"
      }
      if hasCcGenericServices {
        output += "\(indent) ccGenericServices: \(ccGenericServices) \n"
      }
      if hasJavaGenericServices {
        output += "\(indent) javaGenericServices: \(javaGenericServices) \n"
      }
      if hasPyGenericServices {
        output += "\(indent) pyGenericServices: \(pyGenericServices) \n"
      }
      if hasJavaGenerateEqualsAndHash {
        output += "\(indent) javaGenerateEqualsAndHash: \(javaGenerateEqualsAndHash) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      if hasJavaStringCheckUtf8 {
        output += "\(indent) javaStringCheckUtf8: \(javaStringCheckUtf8) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementuninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          oneElementuninterpretedOption.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex++
      }
      writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasJavaPackage {
               hashCode = (hashCode &* 31) &+ javaPackage.hashValue
            }
            if hasJavaOuterClassname {
               hashCode = (hashCode &* 31) &+ javaOuterClassname.hashValue
            }
            if hasOptimizeFor {
               hashCode = (hashCode &* 31) &+ Int(optimizeFor.rawValue)
            }
            if hasJavaMultipleFiles {
               hashCode = (hashCode &* 31) &+ javaMultipleFiles.hashValue
            }
            if hasGoPackage {
               hashCode = (hashCode &* 31) &+ goPackage.hashValue
            }
            if hasCcGenericServices {
               hashCode = (hashCode &* 31) &+ ccGenericServices.hashValue
            }
            if hasJavaGenericServices {
               hashCode = (hashCode &* 31) &+ javaGenericServices.hashValue
            }
            if hasPyGenericServices {
               hashCode = (hashCode &* 31) &+ pyGenericServices.hashValue
            }
            if hasJavaGenerateEqualsAndHash {
               hashCode = (hashCode &* 31) &+ javaGenerateEqualsAndHash.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            if hasJavaStringCheckUtf8 {
               hashCode = (hashCode &* 31) &+ javaStringCheckUtf8.hashValue
            }
            for oneElementuninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementuninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "FileOptions"
    }
    override public func className() -> String {
        return "FileOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return FileOptions.self
    }
    //Meta information declaration end

  }

  final public class FileOptionsBuilder : ExtendableMessageBuilder {
    private var builderResult:FileOptions

    required override public init () {
       builderResult = FileOptions()
       super.init()
    }
    public var hasJavaPackage:Bool {
         get {
              return builderResult.hasJavaPackage
         }
    }
    public var javaPackage:String {
         get {
              return builderResult.javaPackage
         }
         set (value) {
             builderResult.hasJavaPackage = true
             builderResult.javaPackage = value
         }
    }
    public func setJavaPackage(value:String)-> FileOptionsBuilder {
      self.javaPackage = value
      return self
    }
    public func clearJavaPackage() -> FileOptionsBuilder{
         builderResult.hasJavaPackage = false
         builderResult.javaPackage = ""
         return self
    }
    public var hasJavaOuterClassname:Bool {
         get {
              return builderResult.hasJavaOuterClassname
         }
    }
    public var javaOuterClassname:String {
         get {
              return builderResult.javaOuterClassname
         }
         set (value) {
             builderResult.hasJavaOuterClassname = true
             builderResult.javaOuterClassname = value
         }
    }
    public func setJavaOuterClassname(value:String)-> FileOptionsBuilder {
      self.javaOuterClassname = value
      return self
    }
    public func clearJavaOuterClassname() -> FileOptionsBuilder{
         builderResult.hasJavaOuterClassname = false
         builderResult.javaOuterClassname = ""
         return self
    }
    public var hasJavaMultipleFiles:Bool {
         get {
              return builderResult.hasJavaMultipleFiles
         }
    }
    public var javaMultipleFiles:Bool {
         get {
              return builderResult.javaMultipleFiles
         }
         set (value) {
             builderResult.hasJavaMultipleFiles = true
             builderResult.javaMultipleFiles = value
         }
    }
    public func setJavaMultipleFiles(value:Bool)-> FileOptionsBuilder {
      self.javaMultipleFiles = value
      return self
    }
    public func clearJavaMultipleFiles() -> FileOptionsBuilder{
         builderResult.hasJavaMultipleFiles = false
         builderResult.javaMultipleFiles = false
         return self
    }
    public var hasJavaGenerateEqualsAndHash:Bool {
         get {
              return builderResult.hasJavaGenerateEqualsAndHash
         }
    }
    public var javaGenerateEqualsAndHash:Bool {
         get {
              return builderResult.javaGenerateEqualsAndHash
         }
         set (value) {
             builderResult.hasJavaGenerateEqualsAndHash = true
             builderResult.javaGenerateEqualsAndHash = value
         }
    }
    public func setJavaGenerateEqualsAndHash(value:Bool)-> FileOptionsBuilder {
      self.javaGenerateEqualsAndHash = value
      return self
    }
    public func clearJavaGenerateEqualsAndHash() -> FileOptionsBuilder{
         builderResult.hasJavaGenerateEqualsAndHash = false
         builderResult.javaGenerateEqualsAndHash = false
         return self
    }
    public var hasJavaStringCheckUtf8:Bool {
         get {
              return builderResult.hasJavaStringCheckUtf8
         }
    }
    public var javaStringCheckUtf8:Bool {
         get {
              return builderResult.javaStringCheckUtf8
         }
         set (value) {
             builderResult.hasJavaStringCheckUtf8 = true
             builderResult.javaStringCheckUtf8 = value
         }
    }
    public func setJavaStringCheckUtf8(value:Bool)-> FileOptionsBuilder {
      self.javaStringCheckUtf8 = value
      return self
    }
    public func clearJavaStringCheckUtf8() -> FileOptionsBuilder{
         builderResult.hasJavaStringCheckUtf8 = false
         builderResult.javaStringCheckUtf8 = false
         return self
    }
      public var hasOptimizeFor:Bool{
          get {
              return builderResult.hasOptimizeFor
          }
      }
      public var optimizeFor:Google.Protobuf.FileOptions {
          get {
              return builderResult.optimizeFor
          }
          set (value) {
              builderResult.hasOptimizeFor = true
              builderResult.optimizeFor = value
          }
      }
      public func setOptimizeFor(value:Google.Protobuf.FileOptions)-> Google.Protobuf.FileOptionsBuilder {
        self.optimizeFor = value
        return self
      }
      public func clearOptimizeFor() -> Google.Protobuf.FileOptionsBuilder {
         builderResult.hasOptimizeFor = false
         builderResult.optimizeFor = .Speed
         return self
      }
    public var hasGoPackage:Bool {
         get {
              return builderResult.hasGoPackage
         }
    }
    public var goPackage:String {
         get {
              return builderResult.goPackage
         }
         set (value) {
             builderResult.hasGoPackage = true
             builderResult.goPackage = value
         }
    }
    public func setGoPackage(value:String)-> FileOptionsBuilder {
      self.goPackage = value
      return self
    }
    public func clearGoPackage() -> FileOptionsBuilder{
         builderResult.hasGoPackage = false
         builderResult.goPackage = ""
         return self
    }
    public var hasCcGenericServices:Bool {
         get {
              return builderResult.hasCcGenericServices
         }
    }
    public var ccGenericServices:Bool {
         get {
              return builderResult.ccGenericServices
         }
         set (value) {
             builderResult.hasCcGenericServices = true
             builderResult.ccGenericServices = value
         }
    }
    public func setCcGenericServices(value:Bool)-> FileOptionsBuilder {
      self.ccGenericServices = value
      return self
    }
    public func clearCcGenericServices() -> FileOptionsBuilder{
         builderResult.hasCcGenericServices = false
         builderResult.ccGenericServices = false
         return self
    }
    public var hasJavaGenericServices:Bool {
         get {
              return builderResult.hasJavaGenericServices
         }
    }
    public var javaGenericServices:Bool {
         get {
              return builderResult.javaGenericServices
         }
         set (value) {
             builderResult.hasJavaGenericServices = true
             builderResult.javaGenericServices = value
         }
    }
    public func setJavaGenericServices(value:Bool)-> FileOptionsBuilder {
      self.javaGenericServices = value
      return self
    }
    public func clearJavaGenericServices() -> FileOptionsBuilder{
         builderResult.hasJavaGenericServices = false
         builderResult.javaGenericServices = false
         return self
    }
    public var hasPyGenericServices:Bool {
         get {
              return builderResult.hasPyGenericServices
         }
    }
    public var pyGenericServices:Bool {
         get {
              return builderResult.pyGenericServices
         }
         set (value) {
             builderResult.hasPyGenericServices = true
             builderResult.pyGenericServices = value
         }
    }
    public func setPyGenericServices(value:Bool)-> FileOptionsBuilder {
      self.pyGenericServices = value
      return self
    }
    public func clearPyGenericServices() -> FileOptionsBuilder{
         builderResult.hasPyGenericServices = false
         builderResult.pyGenericServices = false
         return self
    }
    public var hasDeprecated:Bool {
         get {
              return builderResult.hasDeprecated
         }
    }
    public var deprecated:Bool {
         get {
              return builderResult.deprecated
         }
         set (value) {
             builderResult.hasDeprecated = true
             builderResult.deprecated = value
         }
    }
    public func setDeprecated(value:Bool)-> FileOptionsBuilder {
      self.deprecated = value
      return self
    }
    public func clearDeprecated() -> FileOptionsBuilder{
         builderResult.hasDeprecated = false
         builderResult.deprecated = false
         return self
    }
    public var uninterpretedOption:Array<UninterpretedOption> {
         get {
             return builderResult.uninterpretedOption
         }
         set (value) {
             builderResult.uninterpretedOption = value
         }
    }
    public func setUninterpretedOption(value:Array<UninterpretedOption>)-> UninterpretedOptionBuilder {
      self.uninterpretedOption = value
      return self
    }
    public func clearUninterpretedOption() -> UninterpretedOptionBuilder {
      builderResult.uninterpretedOption.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> FileOptionsBuilder {
      builderResult = FileOptions()
      return self
    }
    public override func clone() -> FileOptionsBuilder {
      return FileOptions.builderWithPrototype(builderResult)
    }
    public override func build() -> FileOptions {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> FileOptions {
      var returnMe:FileOptions = builderResult
      return returnMe
    }
    public func mergeFrom(other:FileOptions) -> FileOptionsBuilder {
      if (other == FileOptions()) {
       return self
      }
      if other.hasJavaPackage {
           javaPackage = other.javaPackage
      }
      if other.hasJavaOuterClassname {
           javaOuterClassname = other.javaOuterClassname
      }
      if other.hasJavaMultipleFiles {
           javaMultipleFiles = other.javaMultipleFiles
      }
      if other.hasJavaGenerateEqualsAndHash {
           javaGenerateEqualsAndHash = other.javaGenerateEqualsAndHash
      }
      if other.hasJavaStringCheckUtf8 {
           javaStringCheckUtf8 = other.javaStringCheckUtf8
      }
      if other.hasOptimizeFor {
           optimizeFor = other.optimizeFor
      }
      if other.hasGoPackage {
           goPackage = other.goPackage
      }
      if other.hasCcGenericServices {
           ccGenericServices = other.ccGenericServices
      }
      if other.hasJavaGenericServices {
           javaGenericServices = other.javaGenericServices
      }
      if other.hasPyGenericServices {
           pyGenericServices = other.pyGenericServices
      }
      if other.hasDeprecated {
           deprecated = other.deprecated
      }
      if !other.uninterpretedOption.isEmpty  {
         builderResult.uninterpretedOption += other.uninterpretedOption
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->FileOptionsBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FileOptionsBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          javaPackage = input.readString()

        case 66 :
          javaOuterClassname = input.readString()

        case 72 :
          let valueIntoptimizeFor = input.readEnum()
          if let enumsoptimizeFor = Google.Protobuf.FileOptions(rawValue:valueIntoptimizeFor){
               optimizeFor = enumsoptimizeFor
          } else {
               unknownFieldsBuilder.mergeVarintField(9, value:Int64(valueIntoptimizeFor))
          }

        case 80 :
          javaMultipleFiles = input.readBool()

        case 90 :
          goPackage = input.readString()

        case 128 :
          ccGenericServices = input.readBool()

        case 136 :
          javaGenericServices = input.readBool()

        case 144 :
          pyGenericServices = input.readBool()

        case 160 :
          javaGenerateEqualsAndHash = input.readBool()

        case 184 :
          deprecated = input.readBool()

        case 216 :
          javaStringCheckUtf8 = input.readBool()

        case 7994 :
          var subBuilder = UninterpretedOption.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          uninterpretedOption += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class MessageOptions : ExtendableMessage, GeneratedMessageProtocol {
    public private(set) var hasMessageSetWireFormat:Bool = false
    public private(set) var messageSetWireFormat:Bool = false

    public private(set) var hasNoStandardDescriptorAccessor:Bool = false
    public private(set) var noStandardDescriptorAccessor:Bool = false

    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<UninterpretedOption>  = Array<UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInituninterpretedOption:Bool = true
      for oneElementuninterpretedOption in uninterpretedOption {
          if (!oneElementuninterpretedOption.isInitialized()) {
              isInituninterpretedOption = false
              break 
          }
      }
      if !isInituninterpretedOption {
       return isInituninterpretedOption
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasMessageSetWireFormat {
        output.writeBool(1, value:messageSetWireFormat)
      }
      if hasNoStandardDescriptorAccessor {
        output.writeBool(2, value:noStandardDescriptorAccessor)
      }
      if hasDeprecated {
        output.writeBool(3, value:deprecated)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          output.writeMessage(999, value:oneElementuninterpretedOption)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasMessageSetWireFormat {
        serialize_size += messageSetWireFormat.computeBoolSize(1)
      }
      if hasNoStandardDescriptorAccessor {
        serialize_size += noStandardDescriptorAccessor.computeBoolSize(2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(3)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          serialize_size += oneElementuninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> MessageOptions {
      return MessageOptions.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> MessageOptions {
      return MessageOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> MessageOptions {
      return MessageOptions.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MessageOptions {
      return MessageOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> MessageOptions {
      return MessageOptions.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MessageOptions {
      return MessageOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> MessageOptionsBuilder {
      return MessageOptions.classBuilder() as! MessageOptionsBuilder
    }
    public func builder() -> MessageOptionsBuilder {
      return classBuilder() as! MessageOptionsBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return MessageOptionsBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return MessageOptions.builder()
    }
    public func toBuilder() -> MessageOptionsBuilder {
      return MessageOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:MessageOptions) -> MessageOptionsBuilder {
      return MessageOptions.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasMessageSetWireFormat {
        output += "\(indent) messageSetWireFormat: \(messageSetWireFormat) \n"
      }
      if hasNoStandardDescriptorAccessor {
        output += "\(indent) noStandardDescriptorAccessor: \(noStandardDescriptorAccessor) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementuninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          oneElementuninterpretedOption.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex++
      }
      writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMessageSetWireFormat {
               hashCode = (hashCode &* 31) &+ messageSetWireFormat.hashValue
            }
            if hasNoStandardDescriptorAccessor {
               hashCode = (hashCode &* 31) &+ noStandardDescriptorAccessor.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementuninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementuninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "MessageOptions"
    }
    override public func className() -> String {
        return "MessageOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return MessageOptions.self
    }
    //Meta information declaration end

  }

  final public class MessageOptionsBuilder : ExtendableMessageBuilder {
    private var builderResult:MessageOptions

    required override public init () {
       builderResult = MessageOptions()
       super.init()
    }
    public var hasMessageSetWireFormat:Bool {
         get {
              return builderResult.hasMessageSetWireFormat
         }
    }
    public var messageSetWireFormat:Bool {
         get {
              return builderResult.messageSetWireFormat
         }
         set (value) {
             builderResult.hasMessageSetWireFormat = true
             builderResult.messageSetWireFormat = value
         }
    }
    public func setMessageSetWireFormat(value:Bool)-> MessageOptionsBuilder {
      self.messageSetWireFormat = value
      return self
    }
    public func clearMessageSetWireFormat() -> MessageOptionsBuilder{
         builderResult.hasMessageSetWireFormat = false
         builderResult.messageSetWireFormat = false
         return self
    }
    public var hasNoStandardDescriptorAccessor:Bool {
         get {
              return builderResult.hasNoStandardDescriptorAccessor
         }
    }
    public var noStandardDescriptorAccessor:Bool {
         get {
              return builderResult.noStandardDescriptorAccessor
         }
         set (value) {
             builderResult.hasNoStandardDescriptorAccessor = true
             builderResult.noStandardDescriptorAccessor = value
         }
    }
    public func setNoStandardDescriptorAccessor(value:Bool)-> MessageOptionsBuilder {
      self.noStandardDescriptorAccessor = value
      return self
    }
    public func clearNoStandardDescriptorAccessor() -> MessageOptionsBuilder{
         builderResult.hasNoStandardDescriptorAccessor = false
         builderResult.noStandardDescriptorAccessor = false
         return self
    }
    public var hasDeprecated:Bool {
         get {
              return builderResult.hasDeprecated
         }
    }
    public var deprecated:Bool {
         get {
              return builderResult.deprecated
         }
         set (value) {
             builderResult.hasDeprecated = true
             builderResult.deprecated = value
         }
    }
    public func setDeprecated(value:Bool)-> MessageOptionsBuilder {
      self.deprecated = value
      return self
    }
    public func clearDeprecated() -> MessageOptionsBuilder{
         builderResult.hasDeprecated = false
         builderResult.deprecated = false
         return self
    }
    public var uninterpretedOption:Array<UninterpretedOption> {
         get {
             return builderResult.uninterpretedOption
         }
         set (value) {
             builderResult.uninterpretedOption = value
         }
    }
    public func setUninterpretedOption(value:Array<UninterpretedOption>)-> UninterpretedOptionBuilder {
      self.uninterpretedOption = value
      return self
    }
    public func clearUninterpretedOption() -> UninterpretedOptionBuilder {
      builderResult.uninterpretedOption.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> MessageOptionsBuilder {
      builderResult = MessageOptions()
      return self
    }
    public override func clone() -> MessageOptionsBuilder {
      return MessageOptions.builderWithPrototype(builderResult)
    }
    public override func build() -> MessageOptions {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MessageOptions {
      var returnMe:MessageOptions = builderResult
      return returnMe
    }
    public func mergeFrom(other:MessageOptions) -> MessageOptionsBuilder {
      if (other == MessageOptions()) {
       return self
      }
      if other.hasMessageSetWireFormat {
           messageSetWireFormat = other.messageSetWireFormat
      }
      if other.hasNoStandardDescriptorAccessor {
           noStandardDescriptorAccessor = other.noStandardDescriptorAccessor
      }
      if other.hasDeprecated {
           deprecated = other.deprecated
      }
      if !other.uninterpretedOption.isEmpty  {
         builderResult.uninterpretedOption += other.uninterpretedOption
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->MessageOptionsBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MessageOptionsBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          messageSetWireFormat = input.readBool()

        case 16 :
          noStandardDescriptorAccessor = input.readBool()

        case 24 :
          deprecated = input.readBool()

        case 7994 :
          var subBuilder = UninterpretedOption.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          uninterpretedOption += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class FieldOptions : ExtendableMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Ctype:Int32 {
        case String = 0
        case Cord = 1
        case StringPiece = 2

      }

      //Enum type declaration end 

    public private(set) var ctype:Google.Protobuf.FieldOptions = Google.Protobuf.FieldOptions.String
    public private(set) var hasCtype:Bool = false
    public private(set) var hasPacked:Bool = false
    public private(set) var packed:Bool = false

    public private(set) var hasLazy:Bool = false
    public private(set) var lazy:Bool = false

    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var hasExperimentalMapKey:Bool = false
    public private(set) var experimentalMapKey:String = ""

    public private(set) var hasWeak:Bool = false
    public private(set) var weak:Bool = false

    public private(set) var uninterpretedOption:Array<UninterpretedOption>  = Array<UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInituninterpretedOption:Bool = true
      for oneElementuninterpretedOption in uninterpretedOption {
          if (!oneElementuninterpretedOption.isInitialized()) {
              isInituninterpretedOption = false
              break 
          }
      }
      if !isInituninterpretedOption {
       return isInituninterpretedOption
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasCtype {
        output.writeEnum(1, value:ctype.rawValue)
      }
      if hasPacked {
        output.writeBool(2, value:packed)
      }
      if hasDeprecated {
        output.writeBool(3, value:deprecated)
      }
      if hasLazy {
        output.writeBool(5, value:lazy)
      }
      if hasExperimentalMapKey {
        output.writeString(9, value:experimentalMapKey)
      }
      if hasWeak {
        output.writeBool(10, value:weak)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          output.writeMessage(999, value:oneElementuninterpretedOption)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasCtype) {
        serialize_size += ctype.rawValue.computeEnumSize(1)
      }
      if hasPacked {
        serialize_size += packed.computeBoolSize(2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(3)
      }
      if hasLazy {
        serialize_size += lazy.computeBoolSize(5)
      }
      if hasExperimentalMapKey {
        serialize_size += experimentalMapKey.computeStringSize(9)
      }
      if hasWeak {
        serialize_size += weak.computeBoolSize(10)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          serialize_size += oneElementuninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> FieldOptions {
      return FieldOptions.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> FieldOptions {
      return FieldOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> FieldOptions {
      return FieldOptions.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->FieldOptions {
      return FieldOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> FieldOptions {
      return FieldOptions.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FieldOptions {
      return FieldOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> FieldOptionsBuilder {
      return FieldOptions.classBuilder() as! FieldOptionsBuilder
    }
    public func builder() -> FieldOptionsBuilder {
      return classBuilder() as! FieldOptionsBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return FieldOptionsBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return FieldOptions.builder()
    }
    public func toBuilder() -> FieldOptionsBuilder {
      return FieldOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:FieldOptions) -> FieldOptionsBuilder {
      return FieldOptions.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if (hasCtype) {
        output += "\(indent) ctype: \(ctype.rawValue)\n"
      }
      if hasPacked {
        output += "\(indent) packed: \(packed) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      if hasLazy {
        output += "\(indent) lazy: \(lazy) \n"
      }
      if hasExperimentalMapKey {
        output += "\(indent) experimentalMapKey: \(experimentalMapKey) \n"
      }
      if hasWeak {
        output += "\(indent) weak: \(weak) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementuninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          oneElementuninterpretedOption.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex++
      }
      writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCtype {
               hashCode = (hashCode &* 31) &+ Int(ctype.rawValue)
            }
            if hasPacked {
               hashCode = (hashCode &* 31) &+ packed.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            if hasLazy {
               hashCode = (hashCode &* 31) &+ lazy.hashValue
            }
            if hasExperimentalMapKey {
               hashCode = (hashCode &* 31) &+ experimentalMapKey.hashValue
            }
            if hasWeak {
               hashCode = (hashCode &* 31) &+ weak.hashValue
            }
            for oneElementuninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementuninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "FieldOptions"
    }
    override public func className() -> String {
        return "FieldOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return FieldOptions.self
    }
    //Meta information declaration end

  }

  final public class FieldOptionsBuilder : ExtendableMessageBuilder {
    private var builderResult:FieldOptions

    required override public init () {
       builderResult = FieldOptions()
       super.init()
    }
      public var hasCtype:Bool{
          get {
              return builderResult.hasCtype
          }
      }
      public var ctype:Google.Protobuf.FieldOptions {
          get {
              return builderResult.ctype
          }
          set (value) {
              builderResult.hasCtype = true
              builderResult.ctype = value
          }
      }
      public func setCtype(value:Google.Protobuf.FieldOptions)-> Google.Protobuf.FieldOptionsBuilder {
        self.ctype = value
        return self
      }
      public func clearCtype() -> Google.Protobuf.FieldOptionsBuilder {
         builderResult.hasCtype = false
         builderResult.ctype = .String
         return self
      }
    public var hasPacked:Bool {
         get {
              return builderResult.hasPacked
         }
    }
    public var packed:Bool {
         get {
              return builderResult.packed
         }
         set (value) {
             builderResult.hasPacked = true
             builderResult.packed = value
         }
    }
    public func setPacked(value:Bool)-> FieldOptionsBuilder {
      self.packed = value
      return self
    }
    public func clearPacked() -> FieldOptionsBuilder{
         builderResult.hasPacked = false
         builderResult.packed = false
         return self
    }
    public var hasLazy:Bool {
         get {
              return builderResult.hasLazy
         }
    }
    public var lazy:Bool {
         get {
              return builderResult.lazy
         }
         set (value) {
             builderResult.hasLazy = true
             builderResult.lazy = value
         }
    }
    public func setLazy(value:Bool)-> FieldOptionsBuilder {
      self.lazy = value
      return self
    }
    public func clearLazy() -> FieldOptionsBuilder{
         builderResult.hasLazy = false
         builderResult.lazy = false
         return self
    }
    public var hasDeprecated:Bool {
         get {
              return builderResult.hasDeprecated
         }
    }
    public var deprecated:Bool {
         get {
              return builderResult.deprecated
         }
         set (value) {
             builderResult.hasDeprecated = true
             builderResult.deprecated = value
         }
    }
    public func setDeprecated(value:Bool)-> FieldOptionsBuilder {
      self.deprecated = value
      return self
    }
    public func clearDeprecated() -> FieldOptionsBuilder{
         builderResult.hasDeprecated = false
         builderResult.deprecated = false
         return self
    }
    public var hasExperimentalMapKey:Bool {
         get {
              return builderResult.hasExperimentalMapKey
         }
    }
    public var experimentalMapKey:String {
         get {
              return builderResult.experimentalMapKey
         }
         set (value) {
             builderResult.hasExperimentalMapKey = true
             builderResult.experimentalMapKey = value
         }
    }
    public func setExperimentalMapKey(value:String)-> FieldOptionsBuilder {
      self.experimentalMapKey = value
      return self
    }
    public func clearExperimentalMapKey() -> FieldOptionsBuilder{
         builderResult.hasExperimentalMapKey = false
         builderResult.experimentalMapKey = ""
         return self
    }
    public var hasWeak:Bool {
         get {
              return builderResult.hasWeak
         }
    }
    public var weak:Bool {
         get {
              return builderResult.weak
         }
         set (value) {
             builderResult.hasWeak = true
             builderResult.weak = value
         }
    }
    public func setWeak(value:Bool)-> FieldOptionsBuilder {
      self.weak = value
      return self
    }
    public func clearWeak() -> FieldOptionsBuilder{
         builderResult.hasWeak = false
         builderResult.weak = false
         return self
    }
    public var uninterpretedOption:Array<UninterpretedOption> {
         get {
             return builderResult.uninterpretedOption
         }
         set (value) {
             builderResult.uninterpretedOption = value
         }
    }
    public func setUninterpretedOption(value:Array<UninterpretedOption>)-> UninterpretedOptionBuilder {
      self.uninterpretedOption = value
      return self
    }
    public func clearUninterpretedOption() -> UninterpretedOptionBuilder {
      builderResult.uninterpretedOption.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> FieldOptionsBuilder {
      builderResult = FieldOptions()
      return self
    }
    public override func clone() -> FieldOptionsBuilder {
      return FieldOptions.builderWithPrototype(builderResult)
    }
    public override func build() -> FieldOptions {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> FieldOptions {
      var returnMe:FieldOptions = builderResult
      return returnMe
    }
    public func mergeFrom(other:FieldOptions) -> FieldOptionsBuilder {
      if (other == FieldOptions()) {
       return self
      }
      if other.hasCtype {
           ctype = other.ctype
      }
      if other.hasPacked {
           packed = other.packed
      }
      if other.hasLazy {
           lazy = other.lazy
      }
      if other.hasDeprecated {
           deprecated = other.deprecated
      }
      if other.hasExperimentalMapKey {
           experimentalMapKey = other.experimentalMapKey
      }
      if other.hasWeak {
           weak = other.weak
      }
      if !other.uninterpretedOption.isEmpty  {
         builderResult.uninterpretedOption += other.uninterpretedOption
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->FieldOptionsBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> FieldOptionsBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          let valueIntctype = input.readEnum()
          if let enumsctype = Google.Protobuf.FieldOptions(rawValue:valueIntctype){
               ctype = enumsctype
          } else {
               unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntctype))
          }

        case 16 :
          packed = input.readBool()

        case 24 :
          deprecated = input.readBool()

        case 40 :
          lazy = input.readBool()

        case 74 :
          experimentalMapKey = input.readString()

        case 80 :
          weak = input.readBool()

        case 7994 :
          var subBuilder = UninterpretedOption.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          uninterpretedOption += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class EnumOptions : ExtendableMessage, GeneratedMessageProtocol {
    public private(set) var hasAllowAlias:Bool = false
    public private(set) var allowAlias:Bool = false

    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<UninterpretedOption>  = Array<UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInituninterpretedOption:Bool = true
      for oneElementuninterpretedOption in uninterpretedOption {
          if (!oneElementuninterpretedOption.isInitialized()) {
              isInituninterpretedOption = false
              break 
          }
      }
      if !isInituninterpretedOption {
       return isInituninterpretedOption
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasAllowAlias {
        output.writeBool(2, value:allowAlias)
      }
      if hasDeprecated {
        output.writeBool(3, value:deprecated)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          output.writeMessage(999, value:oneElementuninterpretedOption)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasAllowAlias {
        serialize_size += allowAlias.computeBoolSize(2)
      }
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(3)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          serialize_size += oneElementuninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> EnumOptions {
      return EnumOptions.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> EnumOptions {
      return EnumOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> EnumOptions {
      return EnumOptions.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->EnumOptions {
      return EnumOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> EnumOptions {
      return EnumOptions.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> EnumOptions {
      return EnumOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> EnumOptionsBuilder {
      return EnumOptions.classBuilder() as! EnumOptionsBuilder
    }
    public func builder() -> EnumOptionsBuilder {
      return classBuilder() as! EnumOptionsBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return EnumOptionsBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return EnumOptions.builder()
    }
    public func toBuilder() -> EnumOptionsBuilder {
      return EnumOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:EnumOptions) -> EnumOptionsBuilder {
      return EnumOptions.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasAllowAlias {
        output += "\(indent) allowAlias: \(allowAlias) \n"
      }
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementuninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          oneElementuninterpretedOption.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex++
      }
      writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAllowAlias {
               hashCode = (hashCode &* 31) &+ allowAlias.hashValue
            }
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementuninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementuninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "EnumOptions"
    }
    override public func className() -> String {
        return "EnumOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return EnumOptions.self
    }
    //Meta information declaration end

  }

  final public class EnumOptionsBuilder : ExtendableMessageBuilder {
    private var builderResult:EnumOptions

    required override public init () {
       builderResult = EnumOptions()
       super.init()
    }
    public var hasAllowAlias:Bool {
         get {
              return builderResult.hasAllowAlias
         }
    }
    public var allowAlias:Bool {
         get {
              return builderResult.allowAlias
         }
         set (value) {
             builderResult.hasAllowAlias = true
             builderResult.allowAlias = value
         }
    }
    public func setAllowAlias(value:Bool)-> EnumOptionsBuilder {
      self.allowAlias = value
      return self
    }
    public func clearAllowAlias() -> EnumOptionsBuilder{
         builderResult.hasAllowAlias = false
         builderResult.allowAlias = false
         return self
    }
    public var hasDeprecated:Bool {
         get {
              return builderResult.hasDeprecated
         }
    }
    public var deprecated:Bool {
         get {
              return builderResult.deprecated
         }
         set (value) {
             builderResult.hasDeprecated = true
             builderResult.deprecated = value
         }
    }
    public func setDeprecated(value:Bool)-> EnumOptionsBuilder {
      self.deprecated = value
      return self
    }
    public func clearDeprecated() -> EnumOptionsBuilder{
         builderResult.hasDeprecated = false
         builderResult.deprecated = false
         return self
    }
    public var uninterpretedOption:Array<UninterpretedOption> {
         get {
             return builderResult.uninterpretedOption
         }
         set (value) {
             builderResult.uninterpretedOption = value
         }
    }
    public func setUninterpretedOption(value:Array<UninterpretedOption>)-> UninterpretedOptionBuilder {
      self.uninterpretedOption = value
      return self
    }
    public func clearUninterpretedOption() -> UninterpretedOptionBuilder {
      builderResult.uninterpretedOption.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> EnumOptionsBuilder {
      builderResult = EnumOptions()
      return self
    }
    public override func clone() -> EnumOptionsBuilder {
      return EnumOptions.builderWithPrototype(builderResult)
    }
    public override func build() -> EnumOptions {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EnumOptions {
      var returnMe:EnumOptions = builderResult
      return returnMe
    }
    public func mergeFrom(other:EnumOptions) -> EnumOptionsBuilder {
      if (other == EnumOptions()) {
       return self
      }
      if other.hasAllowAlias {
           allowAlias = other.allowAlias
      }
      if other.hasDeprecated {
           deprecated = other.deprecated
      }
      if !other.uninterpretedOption.isEmpty  {
         builderResult.uninterpretedOption += other.uninterpretedOption
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->EnumOptionsBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> EnumOptionsBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 16 :
          allowAlias = input.readBool()

        case 24 :
          deprecated = input.readBool()

        case 7994 :
          var subBuilder = UninterpretedOption.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          uninterpretedOption += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class EnumValueOptions : ExtendableMessage, GeneratedMessageProtocol {
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<UninterpretedOption>  = Array<UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInituninterpretedOption:Bool = true
      for oneElementuninterpretedOption in uninterpretedOption {
          if (!oneElementuninterpretedOption.isInitialized()) {
              isInituninterpretedOption = false
              break 
          }
      }
      if !isInituninterpretedOption {
       return isInituninterpretedOption
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasDeprecated {
        output.writeBool(1, value:deprecated)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          output.writeMessage(999, value:oneElementuninterpretedOption)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(1)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          serialize_size += oneElementuninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> EnumValueOptions {
      return EnumValueOptions.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> EnumValueOptions {
      return EnumValueOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> EnumValueOptions {
      return EnumValueOptions.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->EnumValueOptions {
      return EnumValueOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> EnumValueOptions {
      return EnumValueOptions.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> EnumValueOptions {
      return EnumValueOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> EnumValueOptionsBuilder {
      return EnumValueOptions.classBuilder() as! EnumValueOptionsBuilder
    }
    public func builder() -> EnumValueOptionsBuilder {
      return classBuilder() as! EnumValueOptionsBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return EnumValueOptionsBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return EnumValueOptions.builder()
    }
    public func toBuilder() -> EnumValueOptionsBuilder {
      return EnumValueOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:EnumValueOptions) -> EnumValueOptionsBuilder {
      return EnumValueOptions.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementuninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          oneElementuninterpretedOption.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex++
      }
      writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementuninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementuninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "EnumValueOptions"
    }
    override public func className() -> String {
        return "EnumValueOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return EnumValueOptions.self
    }
    //Meta information declaration end

  }

  final public class EnumValueOptionsBuilder : ExtendableMessageBuilder {
    private var builderResult:EnumValueOptions

    required override public init () {
       builderResult = EnumValueOptions()
       super.init()
    }
    public var hasDeprecated:Bool {
         get {
              return builderResult.hasDeprecated
         }
    }
    public var deprecated:Bool {
         get {
              return builderResult.deprecated
         }
         set (value) {
             builderResult.hasDeprecated = true
             builderResult.deprecated = value
         }
    }
    public func setDeprecated(value:Bool)-> EnumValueOptionsBuilder {
      self.deprecated = value
      return self
    }
    public func clearDeprecated() -> EnumValueOptionsBuilder{
         builderResult.hasDeprecated = false
         builderResult.deprecated = false
         return self
    }
    public var uninterpretedOption:Array<UninterpretedOption> {
         get {
             return builderResult.uninterpretedOption
         }
         set (value) {
             builderResult.uninterpretedOption = value
         }
    }
    public func setUninterpretedOption(value:Array<UninterpretedOption>)-> UninterpretedOptionBuilder {
      self.uninterpretedOption = value
      return self
    }
    public func clearUninterpretedOption() -> UninterpretedOptionBuilder {
      builderResult.uninterpretedOption.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> EnumValueOptionsBuilder {
      builderResult = EnumValueOptions()
      return self
    }
    public override func clone() -> EnumValueOptionsBuilder {
      return EnumValueOptions.builderWithPrototype(builderResult)
    }
    public override func build() -> EnumValueOptions {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> EnumValueOptions {
      var returnMe:EnumValueOptions = builderResult
      return returnMe
    }
    public func mergeFrom(other:EnumValueOptions) -> EnumValueOptionsBuilder {
      if (other == EnumValueOptions()) {
       return self
      }
      if other.hasDeprecated {
           deprecated = other.deprecated
      }
      if !other.uninterpretedOption.isEmpty  {
         builderResult.uninterpretedOption += other.uninterpretedOption
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->EnumValueOptionsBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> EnumValueOptionsBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          deprecated = input.readBool()

        case 7994 :
          var subBuilder = UninterpretedOption.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          uninterpretedOption += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ServiceOptions : ExtendableMessage, GeneratedMessageProtocol {
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<UninterpretedOption>  = Array<UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInituninterpretedOption:Bool = true
      for oneElementuninterpretedOption in uninterpretedOption {
          if (!oneElementuninterpretedOption.isInitialized()) {
              isInituninterpretedOption = false
              break 
          }
      }
      if !isInituninterpretedOption {
       return isInituninterpretedOption
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasDeprecated {
        output.writeBool(33, value:deprecated)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          output.writeMessage(999, value:oneElementuninterpretedOption)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(33)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          serialize_size += oneElementuninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> ServiceOptions {
      return ServiceOptions.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> ServiceOptions {
      return ServiceOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> ServiceOptions {
      return ServiceOptions.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ServiceOptions {
      return ServiceOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> ServiceOptions {
      return ServiceOptions.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ServiceOptions {
      return ServiceOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> ServiceOptionsBuilder {
      return ServiceOptions.classBuilder() as! ServiceOptionsBuilder
    }
    public func builder() -> ServiceOptionsBuilder {
      return classBuilder() as! ServiceOptionsBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return ServiceOptionsBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return ServiceOptions.builder()
    }
    public func toBuilder() -> ServiceOptionsBuilder {
      return ServiceOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:ServiceOptions) -> ServiceOptionsBuilder {
      return ServiceOptions.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementuninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          oneElementuninterpretedOption.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex++
      }
      writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementuninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementuninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ServiceOptions"
    }
    override public func className() -> String {
        return "ServiceOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return ServiceOptions.self
    }
    //Meta information declaration end

  }

  final public class ServiceOptionsBuilder : ExtendableMessageBuilder {
    private var builderResult:ServiceOptions

    required override public init () {
       builderResult = ServiceOptions()
       super.init()
    }
    public var hasDeprecated:Bool {
         get {
              return builderResult.hasDeprecated
         }
    }
    public var deprecated:Bool {
         get {
              return builderResult.deprecated
         }
         set (value) {
             builderResult.hasDeprecated = true
             builderResult.deprecated = value
         }
    }
    public func setDeprecated(value:Bool)-> ServiceOptionsBuilder {
      self.deprecated = value
      return self
    }
    public func clearDeprecated() -> ServiceOptionsBuilder{
         builderResult.hasDeprecated = false
         builderResult.deprecated = false
         return self
    }
    public var uninterpretedOption:Array<UninterpretedOption> {
         get {
             return builderResult.uninterpretedOption
         }
         set (value) {
             builderResult.uninterpretedOption = value
         }
    }
    public func setUninterpretedOption(value:Array<UninterpretedOption>)-> UninterpretedOptionBuilder {
      self.uninterpretedOption = value
      return self
    }
    public func clearUninterpretedOption() -> UninterpretedOptionBuilder {
      builderResult.uninterpretedOption.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> ServiceOptionsBuilder {
      builderResult = ServiceOptions()
      return self
    }
    public override func clone() -> ServiceOptionsBuilder {
      return ServiceOptions.builderWithPrototype(builderResult)
    }
    public override func build() -> ServiceOptions {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ServiceOptions {
      var returnMe:ServiceOptions = builderResult
      return returnMe
    }
    public func mergeFrom(other:ServiceOptions) -> ServiceOptionsBuilder {
      if (other == ServiceOptions()) {
       return self
      }
      if other.hasDeprecated {
           deprecated = other.deprecated
      }
      if !other.uninterpretedOption.isEmpty  {
         builderResult.uninterpretedOption += other.uninterpretedOption
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->ServiceOptionsBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ServiceOptionsBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 264 :
          deprecated = input.readBool()

        case 7994 :
          var subBuilder = UninterpretedOption.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          uninterpretedOption += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class MethodOptions : ExtendableMessage, GeneratedMessageProtocol {
    public private(set) var hasDeprecated:Bool = false
    public private(set) var deprecated:Bool = false

    public private(set) var uninterpretedOption:Array<UninterpretedOption>  = Array<UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInituninterpretedOption:Bool = true
      for oneElementuninterpretedOption in uninterpretedOption {
          if (!oneElementuninterpretedOption.isInitialized()) {
              isInituninterpretedOption = false
              break 
          }
      }
      if !isInituninterpretedOption {
       return isInituninterpretedOption
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasDeprecated {
        output.writeBool(33, value:deprecated)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          output.writeMessage(999, value:oneElementuninterpretedOption)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasDeprecated {
        serialize_size += deprecated.computeBoolSize(33)
      }
      for oneElementuninterpretedOption in uninterpretedOption {
          serialize_size += oneElementuninterpretedOption.computeMessageSize(999)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> MethodOptions {
      return MethodOptions.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> MethodOptions {
      return MethodOptions.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> MethodOptions {
      return MethodOptions.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->MethodOptions {
      return MethodOptions.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> MethodOptions {
      return MethodOptions.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MethodOptions {
      return MethodOptions.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> MethodOptionsBuilder {
      return MethodOptions.classBuilder() as! MethodOptionsBuilder
    }
    public func builder() -> MethodOptionsBuilder {
      return classBuilder() as! MethodOptionsBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return MethodOptionsBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return MethodOptions.builder()
    }
    public func toBuilder() -> MethodOptionsBuilder {
      return MethodOptions.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:MethodOptions) -> MethodOptionsBuilder {
      return MethodOptions.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasDeprecated {
        output += "\(indent) deprecated: \(deprecated) \n"
      }
      var uninterpretedOptionElementIndex:Int = 0
      for oneElementuninterpretedOption in uninterpretedOption {
          output += "\(indent) uninterpretedOption[\(uninterpretedOptionElementIndex)] {\n"
          oneElementuninterpretedOption.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          uninterpretedOptionElementIndex++
      }
      writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDeprecated {
               hashCode = (hashCode &* 31) &+ deprecated.hashValue
            }
            for oneElementuninterpretedOption in uninterpretedOption {
                hashCode = (hashCode &* 31) &+ oneElementuninterpretedOption.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "MethodOptions"
    }
    override public func className() -> String {
        return "MethodOptions"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return MethodOptions.self
    }
    //Meta information declaration end

  }

  final public class MethodOptionsBuilder : ExtendableMessageBuilder {
    private var builderResult:MethodOptions

    required override public init () {
       builderResult = MethodOptions()
       super.init()
    }
    public var hasDeprecated:Bool {
         get {
              return builderResult.hasDeprecated
         }
    }
    public var deprecated:Bool {
         get {
              return builderResult.deprecated
         }
         set (value) {
             builderResult.hasDeprecated = true
             builderResult.deprecated = value
         }
    }
    public func setDeprecated(value:Bool)-> MethodOptionsBuilder {
      self.deprecated = value
      return self
    }
    public func clearDeprecated() -> MethodOptionsBuilder{
         builderResult.hasDeprecated = false
         builderResult.deprecated = false
         return self
    }
    public var uninterpretedOption:Array<UninterpretedOption> {
         get {
             return builderResult.uninterpretedOption
         }
         set (value) {
             builderResult.uninterpretedOption = value
         }
    }
    public func setUninterpretedOption(value:Array<UninterpretedOption>)-> UninterpretedOptionBuilder {
      self.uninterpretedOption = value
      return self
    }
    public func clearUninterpretedOption() -> UninterpretedOptionBuilder {
      builderResult.uninterpretedOption.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> MethodOptionsBuilder {
      builderResult = MethodOptions()
      return self
    }
    public override func clone() -> MethodOptionsBuilder {
      return MethodOptions.builderWithPrototype(builderResult)
    }
    public override func build() -> MethodOptions {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MethodOptions {
      var returnMe:MethodOptions = builderResult
      return returnMe
    }
    public func mergeFrom(other:MethodOptions) -> MethodOptionsBuilder {
      if (other == MethodOptions()) {
       return self
      }
      if other.hasDeprecated {
           deprecated = other.deprecated
      }
      if !other.uninterpretedOption.isEmpty  {
         builderResult.uninterpretedOption += other.uninterpretedOption
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->MethodOptionsBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> MethodOptionsBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 264 :
          deprecated = input.readBool()

        case 7994 :
          var subBuilder = UninterpretedOption.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          uninterpretedOption += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class UninterpretedOption : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class NamePart : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasNamePart:Bool = false
        public private(set) var namePart:String = ""

        public private(set) var hasIsExtension:Bool = false
        public private(set) var isExtension:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
          if !hasNamePart {
            return false
          }
          if !hasIsExtension {
            return false
          }
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) {
          if hasNamePart {
            output.writeString(1, value:namePart)
          }
          if hasIsExtension {
            output.writeBool(2, value:isExtension)
          }
          unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasNamePart {
            serialize_size += namePart.computeStringSize(1)
          }
          if hasIsExtension {
            serialize_size += isExtension.computeBoolSize(2)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseFromData(data:NSData) -> Google.Protobuf.UninterpretedOption {
          return Google.Protobuf.UninterpretedOption.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.UninterpretedOption {
          return Google.Protobuf.UninterpretedOption.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) -> Google.Protobuf.UninterpretedOption {
          return Google.Protobuf.UninterpretedOption.builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Google.Protobuf.UninterpretedOption {
          return Google.Protobuf.UninterpretedOption.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) -> Google.Protobuf.UninterpretedOption {
          return Google.Protobuf.UninterpretedOption.builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.UninterpretedOption {
          return Google.Protobuf.UninterpretedOption.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func builder() -> Google.Protobuf.UninterpretedOptionBuilder {
          return Google.Protobuf.UninterpretedOption.classBuilder() as! Google.Protobuf.UninterpretedOptionBuilder
        }
        public func builder() -> Google.Protobuf.UninterpretedOptionBuilder {
          return classBuilder() as! Google.Protobuf.UninterpretedOptionBuilder
        }
        public override class func classBuilder() -> MessageBuilder {
          return Google.Protobuf.UninterpretedOptionBuilder()
        }
        public override func classBuilder() -> MessageBuilder {
          return Google.Protobuf.UninterpretedOption.builder()
        }
        public func toBuilder() -> Google.Protobuf.UninterpretedOptionBuilder {
          return Google.Protobuf.UninterpretedOption.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.UninterpretedOption) -> Google.Protobuf.UninterpretedOptionBuilder {
          return Google.Protobuf.UninterpretedOption.builder().mergeFrom(prototype)
        }
        override public func writeDescriptionTo(inout output:String, indent:String) {
          if hasNamePart {
            output += "\(indent) namePart: \(namePart) \n"
          }
          if hasIsExtension {
            output += "\(indent) isExtension: \(isExtension) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasNamePart {
                   hashCode = (hashCode &* 31) &+ namePart.hashValue
                }
                if hasIsExtension {
                   hashCode = (hashCode &* 31) &+ isExtension.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.UninterpretedOption"
        }
        override public func className() -> String {
            return "Google.Protobuf.UninterpretedOption"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Google.Protobuf.UninterpretedOption.self
        }
        //Meta information declaration end

      }

      final public class NamePartBuilder : GeneratedMessageBuilder {
        private var builderResult:Google.Protobuf.UninterpretedOption

        required override public init () {
           builderResult = Google.Protobuf.UninterpretedOption()
           super.init()
        }
        public var hasNamePart:Bool {
             get {
                  return builderResult.hasNamePart
             }
        }
        public var namePart:String {
             get {
                  return builderResult.namePart
             }
             set (value) {
                 builderResult.hasNamePart = true
                 builderResult.namePart = value
             }
        }
        public func setNamePart(value:String)-> NamePartBuilder {
          self.namePart = value
          return self
        }
        public func clearNamePart() -> NamePartBuilder{
             builderResult.hasNamePart = false
             builderResult.namePart = ""
             return self
        }
        public var hasIsExtension:Bool {
             get {
                  return builderResult.hasIsExtension
             }
        }
        public var isExtension:Bool {
             get {
                  return builderResult.isExtension
             }
             set (value) {
                 builderResult.hasIsExtension = true
                 builderResult.isExtension = value
             }
        }
        public func setIsExtension(value:Bool)-> NamePartBuilder {
          self.isExtension = value
          return self
        }
        public func clearIsExtension() -> NamePartBuilder{
             builderResult.hasIsExtension = false
             builderResult.isExtension = false
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> Google.Protobuf.UninterpretedOptionBuilder {
          builderResult = Google.Protobuf.UninterpretedOption()
          return self
        }
        public override func clone() -> Google.Protobuf.UninterpretedOptionBuilder {
          return Google.Protobuf.UninterpretedOption.builderWithPrototype(builderResult)
        }
        public override func build() -> Google.Protobuf.UninterpretedOption {
             checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> Google.Protobuf.UninterpretedOption {
          var returnMe:Google.Protobuf.UninterpretedOption = builderResult
          return returnMe
        }
        public func mergeFrom(other:Google.Protobuf.UninterpretedOption) -> Google.Protobuf.UninterpretedOptionBuilder {
          if (other == Google.Protobuf.UninterpretedOption()) {
           return self
          }
          if other.hasNamePart {
               namePart = other.namePart
          }
          if other.hasIsExtension {
               isExtension = other.isExtension
          }
          mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) ->Google.Protobuf.UninterpretedOptionBuilder {
             return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.UninterpretedOptionBuilder {
          var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            var tag = input.readTag()
            switch tag {
            case 0: 
              self.unknownFields = unknownFieldsBuilder.build()
              return self

            case 10 :
              namePart = input.readString()

            case 16 :
              isExtension = input.readBool()

            default:
              if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                 unknownFields = unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    //Nested type declaration end

    public private(set) var hasIdentifierValue:Bool = false
    public private(set) var identifierValue:String = ""

    public private(set) var hasPositiveIntValue:Bool = false
    public private(set) var positiveIntValue:UInt64 = UInt64(0)

    public private(set) var hasNegativeIntValue:Bool = false
    public private(set) var negativeIntValue:Int64 = Int64(0)

    public private(set) var hasDoubleValue:Bool = false
    public private(set) var doubleValue:Double = Double(0)

    public private(set) var hasStringValue:Bool = false
    public private(set) var stringValue:NSData = NSData()

    public private(set) var hasAggregateValue:Bool = false
    public private(set) var aggregateValue:String = ""

    public private(set) var name:Array<Google.Protobuf.UninterpretedOption>  = Array<Google.Protobuf.UninterpretedOption>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitname:Bool = true
      for oneElementname in name {
          if (!oneElementname.isInitialized()) {
              isInitname = false
              break 
          }
      }
      if !isInitname {
       return isInitname
       }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      for oneElementname in name {
          output.writeMessage(2, value:oneElementname)
      }
      if hasIdentifierValue {
        output.writeString(3, value:identifierValue)
      }
      if hasPositiveIntValue {
        output.writeUInt64(4, value:positiveIntValue)
      }
      if hasNegativeIntValue {
        output.writeInt64(5, value:negativeIntValue)
      }
      if hasDoubleValue {
        output.writeDouble(6, value:doubleValue)
      }
      if hasStringValue {
        output.writeData(7, value:stringValue)
      }
      if hasAggregateValue {
        output.writeString(8, value:aggregateValue)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementname in name {
          serialize_size += oneElementname.computeMessageSize(2)
      }
      if hasIdentifierValue {
        serialize_size += identifierValue.computeStringSize(3)
      }
      if hasPositiveIntValue {
        serialize_size += positiveIntValue.computeUInt64Size(4)
      }
      if hasNegativeIntValue {
        serialize_size += negativeIntValue.computeInt64Size(5)
      }
      if hasDoubleValue {
        serialize_size += doubleValue.computeDoubleSize(6)
      }
      if hasStringValue {
        serialize_size += stringValue.computeDataSize(7)
      }
      if hasAggregateValue {
        serialize_size += aggregateValue.computeStringSize(8)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> UninterpretedOption {
      return UninterpretedOption.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> UninterpretedOption {
      return UninterpretedOption.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> UninterpretedOption {
      return UninterpretedOption.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UninterpretedOption {
      return UninterpretedOption.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> UninterpretedOption {
      return UninterpretedOption.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UninterpretedOption {
      return UninterpretedOption.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> UninterpretedOptionBuilder {
      return UninterpretedOption.classBuilder() as! UninterpretedOptionBuilder
    }
    public func builder() -> UninterpretedOptionBuilder {
      return classBuilder() as! UninterpretedOptionBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return UninterpretedOptionBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return UninterpretedOption.builder()
    }
    public func toBuilder() -> UninterpretedOptionBuilder {
      return UninterpretedOption.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:UninterpretedOption) -> UninterpretedOptionBuilder {
      return UninterpretedOption.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      var nameElementIndex:Int = 0
      for oneElementname in name {
          output += "\(indent) name[\(nameElementIndex)] {\n"
          oneElementname.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          nameElementIndex++
      }
      if hasIdentifierValue {
        output += "\(indent) identifierValue: \(identifierValue) \n"
      }
      if hasPositiveIntValue {
        output += "\(indent) positiveIntValue: \(positiveIntValue) \n"
      }
      if hasNegativeIntValue {
        output += "\(indent) negativeIntValue: \(negativeIntValue) \n"
      }
      if hasDoubleValue {
        output += "\(indent) doubleValue: \(doubleValue) \n"
      }
      if hasStringValue {
        output += "\(indent) stringValue: \(stringValue) \n"
      }
      if hasAggregateValue {
        output += "\(indent) aggregateValue: \(aggregateValue) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementname in name {
                hashCode = (hashCode &* 31) &+ oneElementname.hashValue
            }
            if hasIdentifierValue {
               hashCode = (hashCode &* 31) &+ identifierValue.hashValue
            }
            if hasPositiveIntValue {
               hashCode = (hashCode &* 31) &+ positiveIntValue.hashValue
            }
            if hasNegativeIntValue {
               hashCode = (hashCode &* 31) &+ negativeIntValue.hashValue
            }
            if hasDoubleValue {
               hashCode = (hashCode &* 31) &+ doubleValue.hashValue
            }
            if hasStringValue {
               hashCode = (hashCode &* 31) &+ stringValue.hashValue
            }
            if hasAggregateValue {
               hashCode = (hashCode &* 31) &+ aggregateValue.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "UninterpretedOption"
    }
    override public func className() -> String {
        return "UninterpretedOption"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return UninterpretedOption.self
    }
    //Meta information declaration end

  }

  final public class UninterpretedOptionBuilder : GeneratedMessageBuilder {
    private var builderResult:UninterpretedOption

    required override public init () {
       builderResult = UninterpretedOption()
       super.init()
    }
    public var name:Array<Google.Protobuf.UninterpretedOption> {
         get {
             return builderResult.name
         }
         set (value) {
             builderResult.name = value
         }
    }
    public func setName(value:Array<Google.Protobuf.UninterpretedOption>)-> Google.Protobuf.UninterpretedOptionBuilder {
      self.name = value
      return self
    }
    public func clearName() -> Google.Protobuf.UninterpretedOptionBuilder {
      builderResult.name.removeAll(keepCapacity: false)
      return self
    }
    public var hasIdentifierValue:Bool {
         get {
              return builderResult.hasIdentifierValue
         }
    }
    public var identifierValue:String {
         get {
              return builderResult.identifierValue
         }
         set (value) {
             builderResult.hasIdentifierValue = true
             builderResult.identifierValue = value
         }
    }
    public func setIdentifierValue(value:String)-> UninterpretedOptionBuilder {
      self.identifierValue = value
      return self
    }
    public func clearIdentifierValue() -> UninterpretedOptionBuilder{
         builderResult.hasIdentifierValue = false
         builderResult.identifierValue = ""
         return self
    }
    public var hasPositiveIntValue:Bool {
         get {
              return builderResult.hasPositiveIntValue
         }
    }
    public var positiveIntValue:UInt64 {
         get {
              return builderResult.positiveIntValue
         }
         set (value) {
             builderResult.hasPositiveIntValue = true
             builderResult.positiveIntValue = value
         }
    }
    public func setPositiveIntValue(value:UInt64)-> UninterpretedOptionBuilder {
      self.positiveIntValue = value
      return self
    }
    public func clearPositiveIntValue() -> UninterpretedOptionBuilder{
         builderResult.hasPositiveIntValue = false
         builderResult.positiveIntValue = UInt64(0)
         return self
    }
    public var hasNegativeIntValue:Bool {
         get {
              return builderResult.hasNegativeIntValue
         }
    }
    public var negativeIntValue:Int64 {
         get {
              return builderResult.negativeIntValue
         }
         set (value) {
             builderResult.hasNegativeIntValue = true
             builderResult.negativeIntValue = value
         }
    }
    public func setNegativeIntValue(value:Int64)-> UninterpretedOptionBuilder {
      self.negativeIntValue = value
      return self
    }
    public func clearNegativeIntValue() -> UninterpretedOptionBuilder{
         builderResult.hasNegativeIntValue = false
         builderResult.negativeIntValue = Int64(0)
         return self
    }
    public var hasDoubleValue:Bool {
         get {
              return builderResult.hasDoubleValue
         }
    }
    public var doubleValue:Double {
         get {
              return builderResult.doubleValue
         }
         set (value) {
             builderResult.hasDoubleValue = true
             builderResult.doubleValue = value
         }
    }
    public func setDoubleValue(value:Double)-> UninterpretedOptionBuilder {
      self.doubleValue = value
      return self
    }
    public func clearDoubleValue() -> UninterpretedOptionBuilder{
         builderResult.hasDoubleValue = false
         builderResult.doubleValue = Double(0)
         return self
    }
    public var hasStringValue:Bool {
         get {
              return builderResult.hasStringValue
         }
    }
    public var stringValue:NSData {
         get {
              return builderResult.stringValue
         }
         set (value) {
             builderResult.hasStringValue = true
             builderResult.stringValue = value
         }
    }
    public func setStringValue(value:NSData)-> UninterpretedOptionBuilder {
      self.stringValue = value
      return self
    }
    public func clearStringValue() -> UninterpretedOptionBuilder{
         builderResult.hasStringValue = false
         builderResult.stringValue = NSData()
         return self
    }
    public var hasAggregateValue:Bool {
         get {
              return builderResult.hasAggregateValue
         }
    }
    public var aggregateValue:String {
         get {
              return builderResult.aggregateValue
         }
         set (value) {
             builderResult.hasAggregateValue = true
             builderResult.aggregateValue = value
         }
    }
    public func setAggregateValue(value:String)-> UninterpretedOptionBuilder {
      self.aggregateValue = value
      return self
    }
    public func clearAggregateValue() -> UninterpretedOptionBuilder{
         builderResult.hasAggregateValue = false
         builderResult.aggregateValue = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> UninterpretedOptionBuilder {
      builderResult = UninterpretedOption()
      return self
    }
    public override func clone() -> UninterpretedOptionBuilder {
      return UninterpretedOption.builderWithPrototype(builderResult)
    }
    public override func build() -> UninterpretedOption {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> UninterpretedOption {
      var returnMe:UninterpretedOption = builderResult
      return returnMe
    }
    public func mergeFrom(other:UninterpretedOption) -> UninterpretedOptionBuilder {
      if (other == UninterpretedOption()) {
       return self
      }
      if !other.name.isEmpty  {
         builderResult.name += other.name
      }
      if other.hasIdentifierValue {
           identifierValue = other.identifierValue
      }
      if other.hasPositiveIntValue {
           positiveIntValue = other.positiveIntValue
      }
      if other.hasNegativeIntValue {
           negativeIntValue = other.negativeIntValue
      }
      if other.hasDoubleValue {
           doubleValue = other.doubleValue
      }
      if other.hasStringValue {
           stringValue = other.stringValue
      }
      if other.hasAggregateValue {
           aggregateValue = other.aggregateValue
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->UninterpretedOptionBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UninterpretedOptionBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 18 :
          var subBuilder = Google.Protobuf.UninterpretedOption.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          name += [subBuilder.buildPartial()]

        case 26 :
          identifierValue = input.readString()

        case 32 :
          positiveIntValue = input.readUInt64()

        case 40 :
          negativeIntValue = input.readInt64()

        case 49 :
          doubleValue = input.readDouble()

        case 58 :
          stringValue = input.readData()

        case 66 :
          aggregateValue = input.readString()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class SourceCodeInfo : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class Location : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasLeadingComments:Bool = false
        public private(set) var leadingComments:String = ""

        public private(set) var hasTrailingComments:Bool = false
        public private(set) var trailingComments:String = ""

        public private(set) var path:Array<Int32> = Array<Int32>()
        private var pathMemoizedSerializedSize:Int32 = -1
        public private(set) var span:Array<Int32> = Array<Int32>()
        private var spanMemoizedSerializedSize:Int32 = -1
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) {
          if !path.isEmpty {
            output.writeRawVarint32(10)
            output.writeRawVarint32(pathMemoizedSerializedSize)
            for oneValuepath in path {
              output.writeInt32NoTag(oneValuepath)
            }
          }
          if !span.isEmpty {
            output.writeRawVarint32(18)
            output.writeRawVarint32(spanMemoizedSerializedSize)
            for oneValuespan in span {
              output.writeInt32NoTag(oneValuespan)
            }
          }
          if hasLeadingComments {
            output.writeString(3, value:leadingComments)
          }
          if hasTrailingComments {
            output.writeString(4, value:trailingComments)
          }
          unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          var dataSizePath:Int32 = 0
          for oneValuepath in path {
              dataSizePath += oneValuepath.computeInt32SizeNoTag()
          }
          serialize_size += dataSizePath
          if !path.isEmpty {
            serialize_size += 1
            serialize_size += dataSizePath.computeInt32SizeNoTag()
          }
          pathMemoizedSerializedSize = dataSizePath
          var dataSizeSpan:Int32 = 0
          for oneValuespan in span {
              dataSizeSpan += oneValuespan.computeInt32SizeNoTag()
          }
          serialize_size += dataSizeSpan
          if !span.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeSpan.computeInt32SizeNoTag()
          }
          spanMemoizedSerializedSize = dataSizeSpan
          if hasLeadingComments {
            serialize_size += leadingComments.computeStringSize(3)
          }
          if hasTrailingComments {
            serialize_size += trailingComments.computeStringSize(4)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseFromData(data:NSData) -> Google.Protobuf.SourceCodeInfo {
          return Google.Protobuf.SourceCodeInfo.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.SourceCodeInfo {
          return Google.Protobuf.SourceCodeInfo.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) -> Google.Protobuf.SourceCodeInfo {
          return Google.Protobuf.SourceCodeInfo.builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Google.Protobuf.SourceCodeInfo {
          return Google.Protobuf.SourceCodeInfo.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) -> Google.Protobuf.SourceCodeInfo {
          return Google.Protobuf.SourceCodeInfo.builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.SourceCodeInfo {
          return Google.Protobuf.SourceCodeInfo.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func builder() -> Google.Protobuf.SourceCodeInfoBuilder {
          return Google.Protobuf.SourceCodeInfo.classBuilder() as! Google.Protobuf.SourceCodeInfoBuilder
        }
        public func builder() -> Google.Protobuf.SourceCodeInfoBuilder {
          return classBuilder() as! Google.Protobuf.SourceCodeInfoBuilder
        }
        public override class func classBuilder() -> MessageBuilder {
          return Google.Protobuf.SourceCodeInfoBuilder()
        }
        public override func classBuilder() -> MessageBuilder {
          return Google.Protobuf.SourceCodeInfo.builder()
        }
        public func toBuilder() -> Google.Protobuf.SourceCodeInfoBuilder {
          return Google.Protobuf.SourceCodeInfo.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:Google.Protobuf.SourceCodeInfo) -> Google.Protobuf.SourceCodeInfoBuilder {
          return Google.Protobuf.SourceCodeInfo.builder().mergeFrom(prototype)
        }
        override public func writeDescriptionTo(inout output:String, indent:String) {
          var pathElementIndex:Int = 0
          for oneValuepath in path  {
              output += "\(indent) path[\(pathElementIndex)]: \(oneValuepath)\n"
              pathElementIndex++
          }
          var spanElementIndex:Int = 0
          for oneValuespan in span  {
              output += "\(indent) span[\(spanElementIndex)]: \(oneValuespan)\n"
              spanElementIndex++
          }
          if hasLeadingComments {
            output += "\(indent) leadingComments: \(leadingComments) \n"
          }
          if hasTrailingComments {
            output += "\(indent) trailingComments: \(trailingComments) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValuepath in path {
                    hashCode = (hashCode &* 31) &+ oneValuepath.hashValue
                }
                for oneValuespan in span {
                    hashCode = (hashCode &* 31) &+ oneValuespan.hashValue
                }
                if hasLeadingComments {
                   hashCode = (hashCode &* 31) &+ leadingComments.hashValue
                }
                if hasTrailingComments {
                   hashCode = (hashCode &* 31) &+ trailingComments.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Google.Protobuf.SourceCodeInfo"
        }
        override public func className() -> String {
            return "Google.Protobuf.SourceCodeInfo"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Google.Protobuf.SourceCodeInfo.self
        }
        //Meta information declaration end

      }

      final public class LocationBuilder : GeneratedMessageBuilder {
        private var builderResult:Google.Protobuf.SourceCodeInfo

        required override public init () {
           builderResult = Google.Protobuf.SourceCodeInfo()
           super.init()
        }
        public var path:Array<Int32> {
             get {
                 return builderResult.path
             }
             set (array) {
                 builderResult.path = array
             }
        }
        public func setPath(value:Array<Int32>)-> LocationBuilder {
          self.path = value
          return self
        }
        public func clearPath() -> LocationBuilder {
           builderResult.path.removeAll(keepCapacity: false)
           return self
        }
        public var span:Array<Int32> {
             get {
                 return builderResult.span
             }
             set (array) {
                 builderResult.span = array
             }
        }
        public func setSpan(value:Array<Int32>)-> LocationBuilder {
          self.span = value
          return self
        }
        public func clearSpan() -> LocationBuilder {
           builderResult.span.removeAll(keepCapacity: false)
           return self
        }
        public var hasLeadingComments:Bool {
             get {
                  return builderResult.hasLeadingComments
             }
        }
        public var leadingComments:String {
             get {
                  return builderResult.leadingComments
             }
             set (value) {
                 builderResult.hasLeadingComments = true
                 builderResult.leadingComments = value
             }
        }
        public func setLeadingComments(value:String)-> LocationBuilder {
          self.leadingComments = value
          return self
        }
        public func clearLeadingComments() -> LocationBuilder{
             builderResult.hasLeadingComments = false
             builderResult.leadingComments = ""
             return self
        }
        public var hasTrailingComments:Bool {
             get {
                  return builderResult.hasTrailingComments
             }
        }
        public var trailingComments:String {
             get {
                  return builderResult.trailingComments
             }
             set (value) {
                 builderResult.hasTrailingComments = true
                 builderResult.trailingComments = value
             }
        }
        public func setTrailingComments(value:String)-> LocationBuilder {
          self.trailingComments = value
          return self
        }
        public func clearTrailingComments() -> LocationBuilder{
             builderResult.hasTrailingComments = false
             builderResult.trailingComments = ""
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> Google.Protobuf.SourceCodeInfoBuilder {
          builderResult = Google.Protobuf.SourceCodeInfo()
          return self
        }
        public override func clone() -> Google.Protobuf.SourceCodeInfoBuilder {
          return Google.Protobuf.SourceCodeInfo.builderWithPrototype(builderResult)
        }
        public override func build() -> Google.Protobuf.SourceCodeInfo {
             checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> Google.Protobuf.SourceCodeInfo {
          var returnMe:Google.Protobuf.SourceCodeInfo = builderResult
          return returnMe
        }
        public func mergeFrom(other:Google.Protobuf.SourceCodeInfo) -> Google.Protobuf.SourceCodeInfoBuilder {
          if (other == Google.Protobuf.SourceCodeInfo()) {
           return self
          }
          if !other.path.isEmpty {
              builderResult.path += other.path
          }
          if !other.span.isEmpty {
              builderResult.span += other.span
          }
          if other.hasLeadingComments {
               leadingComments = other.leadingComments
          }
          if other.hasTrailingComments {
               trailingComments = other.trailingComments
          }
          mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) ->Google.Protobuf.SourceCodeInfoBuilder {
             return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Google.Protobuf.SourceCodeInfoBuilder {
          var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            var tag = input.readTag()
            switch tag {
            case 0: 
              self.unknownFields = unknownFieldsBuilder.build()
              return self

            case 10 :
              var length:Int32 = input.readRawVarint32()
              var limit:Int32 = input.pushLimit(length)
              while (input.bytesUntilLimit() > 0) {
                builderResult.path += [input.readInt32()]
              }
              input.popLimit(limit)

            case 18 :
              var length:Int32 = input.readRawVarint32()
              var limit:Int32 = input.pushLimit(length)
              while (input.bytesUntilLimit() > 0) {
                builderResult.span += [input.readInt32()]
              }
              input.popLimit(limit)

            case 26 :
              leadingComments = input.readString()

            case 34 :
              trailingComments = input.readString()

            default:
              if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                 unknownFields = unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    //Nested type declaration end

    public private(set) var location:Array<Google.Protobuf.SourceCodeInfo>  = Array<Google.Protobuf.SourceCodeInfo>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      for oneElementlocation in location {
          output.writeMessage(1, value:oneElementlocation)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementlocation in location {
          serialize_size += oneElementlocation.computeMessageSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> SourceCodeInfo {
      return SourceCodeInfo.builder().mergeFromData(data, extensionRegistry:Google.Protobuf.DescriptorRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> SourceCodeInfo {
      return SourceCodeInfo.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> SourceCodeInfo {
      return SourceCodeInfo.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->SourceCodeInfo {
      return SourceCodeInfo.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> SourceCodeInfo {
      return SourceCodeInfo.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SourceCodeInfo {
      return SourceCodeInfo.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> SourceCodeInfoBuilder {
      return SourceCodeInfo.classBuilder() as! SourceCodeInfoBuilder
    }
    public func builder() -> SourceCodeInfoBuilder {
      return classBuilder() as! SourceCodeInfoBuilder
    }
    public override class func classBuilder() -> MessageBuilder {
      return SourceCodeInfoBuilder()
    }
    public override func classBuilder() -> MessageBuilder {
      return SourceCodeInfo.builder()
    }
    public func toBuilder() -> SourceCodeInfoBuilder {
      return SourceCodeInfo.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:SourceCodeInfo) -> SourceCodeInfoBuilder {
      return SourceCodeInfo.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      var locationElementIndex:Int = 0
      for oneElementlocation in location {
          output += "\(indent) location[\(locationElementIndex)] {\n"
          oneElementlocation.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          locationElementIndex++
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementlocation in location {
                hashCode = (hashCode &* 31) &+ oneElementlocation.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SourceCodeInfo"
    }
    override public func className() -> String {
        return "SourceCodeInfo"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return SourceCodeInfo.self
    }
    //Meta information declaration end

  }

  final public class SourceCodeInfoBuilder : GeneratedMessageBuilder {
    private var builderResult:SourceCodeInfo

    required override public init () {
       builderResult = SourceCodeInfo()
       super.init()
    }
    public var location:Array<Google.Protobuf.SourceCodeInfo> {
         get {
             return builderResult.location
         }
         set (value) {
             builderResult.location = value
         }
    }
    public func setLocation(value:Array<Google.Protobuf.SourceCodeInfo>)-> Google.Protobuf.SourceCodeInfoBuilder {
      self.location = value
      return self
    }
    public func clearLocation() -> Google.Protobuf.SourceCodeInfoBuilder {
      builderResult.location.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SourceCodeInfoBuilder {
      builderResult = SourceCodeInfo()
      return self
    }
    public override func clone() -> SourceCodeInfoBuilder {
      return SourceCodeInfo.builderWithPrototype(builderResult)
    }
    public override func build() -> SourceCodeInfo {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SourceCodeInfo {
      var returnMe:SourceCodeInfo = builderResult
      return returnMe
    }
    public func mergeFrom(other:SourceCodeInfo) -> SourceCodeInfoBuilder {
      if (other == SourceCodeInfo()) {
       return self
      }
      if !other.location.isEmpty  {
         builderResult.location += other.location
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->SourceCodeInfoBuilder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> SourceCodeInfoBuilder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 10 :
          var subBuilder = Google.Protobuf.SourceCodeInfo.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          location += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// @@protoc_insertion_point(global_scope)
